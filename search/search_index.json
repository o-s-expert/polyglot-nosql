{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NoSQL Polyglot Persistence Workhop","text":""},{"location":"#how-will-the-dynamic","title":"How will the dynamic","text":"<p>This workshop will be conducted as:</p> <ul> <li>presentation (slides) about what we will learn</li> <li>hands-on labs, timeboxed, to create the solutions</li> <li>double-check the code created</li> </ul> <p>Do</p> <ul> <li>Ask questions, we have one rule: there's no silly/stupid question</li> <li>Interact at any time: you don't need to wait until a full explanation to say something</li> <li>Ask for help when you need it: this is the facilitator's work</li> <li>If you feel comfortable, help the person sit on your side</li> </ul> <p>Don't</p> <ul> <li>Don't leave this session without giving feedback, constructive or positive</li> <li>Don't hesitate to reach out after the session with questions</li> </ul>"},{"location":"setup/","title":"Machine Setup","text":"<p>The first thing we need to do is to check the setup and download the necessary project to run the tests.</p>"},{"location":"setup/#1-check-your-machine","title":"1. Check your machine","text":"<ul> <li> JDK 17 + installed</li> <li> Modern IDE (Intellij, VSCode, etc...)</li> <li> Git</li> <li> Docker</li> <li> Docker Compose</li> <li> curl</li> </ul>"},{"location":"setup/#2-download-the-slides","title":"2. Download the slides","text":"<p>WIP!</p>"},{"location":"setup/#3-download-the-project","title":"3. Download the project","text":""},{"location":"setup/#31-clone-the-project","title":"3.1 Clone the Project","text":"<p>To download the project and its source code from the GitHub repository, open your terminal and execute the following command:</p> <pre><code>git clone git@github.com:ultimate-engineer/polyglot-nosql-lab.git\n</code></pre> <p>This will clone the project's repository to your local machine.</p>"},{"location":"setup/#32-navigate-to-the-project-directory","title":"3.2 Navigate to the Project Directory","text":"<p>Change your working directory to the project's directory:</p> <pre><code>cd polyglot-nosql-lab\n</code></pre>"},{"location":"setup/#33-download-maven-dependencies","title":"3.3 Download Maven Dependencies","text":"<p>Execute the following Maven command to download project dependencies, compile the source code, and run tests:</p> <pre><code>mvn clean verify\n</code></pre> <p>Maven will resolve the project's dependencies, build the code, and run the verification process. If all goes well, you'll have successfully downloaded and built the project.</p>"},{"location":"setup/#34-download-docker-images","title":"3.4 Download Docker Images","text":"<p>To run the project, you'll need Docker images for various databases. You can download these images using Docker commands.</p> <ul> <li> <p>Redis:</p> <pre><code>docker pull redis\n</code></pre> </li> <li> <p>Cassandra:</p> <pre><code>docker pull cassandra\n</code></pre> </li> <li> <p>MongoDB:</p> <pre><code>docker pull mongo\n</code></pre> </li> <li> <p>Neo4j:</p> <pre><code>docker pull neo4j\n</code></pre> </li> </ul> <p>After executing these commands, Docker will download the required images to your local machine. You'll have Redis, Cassandra, MongoDB, and Neo4j images available for use with the project.</p>"},{"location":"setup/#35-done","title":"3.5 Done!","text":"<p>Now you have successfully downloaded the project, its source code, and the necessary dependencies. Additionally, you have the required Docker images to run the project's associated databases. You're ready to work with the Polyglot NoSQL project!</p>"},{"location":"column/cassandra/","title":"Cassandra Overview","text":"<p>Cassandra, an open-source distributed NoSQL database system, is designed for managing massive amounts of data across multiple commodity servers while ensuring high availability and fault tolerance. Cassandra's decentralized architecture, built for horizontal scalability, makes it a resilient choice for handling large-scale data-intensive applications, including real-time analytics, content management systems, and Internet of Things (IoT) platforms. Its robust support for linear scalability, fault tolerance, eventual consistency, and flexible schema design enables organizations to tackle modern data challenges by effortlessly scaling their data infrastructure and maintaining data integrity, making Cassandra a pivotal player in the NoSQL database landscape.</p>"},{"location":"column/cassandra/#main-features","title":"Main features","text":"<ol> <li> <p>Distributed Architecture: Cassandra is built as a distributed database, allowing it to manage large datasets across multiple nodes or clusters, ensuring scalability and fault tolerance.</p> </li> <li> <p>Linear Scalability: Cassandra exhibits linear scalability, meaning you can add more nodes to the cluster as data volume and traffic grow, making it suitable for applications with varying workloads.</p> </li> <li> <p>High Availability: Cassandra ensures data availability by replicating data across nodes. No single point of failure contributes to the system's robustness.</p> </li> <li> <p>NoSQL Data Model: Cassandra uses a flexible, schema-less NoSQL data model that accommodates dynamic changes in the data structure, making it agile and adaptable.</p> </li> <li> <p>Tunable Consistency Levels: Cassandra offers tunable consistency levels, enabling developers to balance data consistency and availability according to application requirements.</p> </li> <li> <p>Wide-Column Store: Cassandra stores data in a wide-column format, optimizing data retrieval and query performance, particularly for analytical workloads.</p> </li> <li> <p>Built-in Caching: Cassandra includes an integrated caching mechanism that enhances read performance by storing frequently accessed data in memory.</p> </li> <li> <p>Multi-Datacenter Support: Cassandra supports multi-datacenter replication, facilitating global user disaster recovery and low-latency access.</p> </li> <li> <p>Time-Series Data Handling: Cassandra is well-suited for storing time-series data, making it ideal for applications like IoT, monitoring, and financial analytics.</p> </li> <li> <p>Security Features: Cassandra provides various security features, including authentication, authorization, and encryption, ensuring data protection and access control.</p> </li> </ol>"},{"location":"column/commands/","title":"Cassandra Query Language (CQL) commands:","text":"Command Description <code>CREATE KEYSPACE keyspace_name WITH replication = {'class':'SimpleStrategy', 'replication_factor':1};</code> Create a keyspace with specified replication settings. <code>USE keyspace_name;</code> Switch to a specific keyspace to perform operations within it. <code>CREATE TABLE table_name (column_definitions PRIMARY KEY (primary_key_column));</code> Create a table with defined columns and a primary key. <code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);</code> Insert data into a table with specified column values. <code>SELECT * FROM table_name;</code> Retrieve all rows from a table. <code>UPDATE table_name SET column1 = value1 WHERE primary_key_column = key_value;</code> Update data in a table based on the primary key. <code>DELETE FROM table_name WHERE primary_key_column = key_value;</code> Delete data from a table based on the primary key. <code>ALTER TABLE table_name ADD column_name datatype;</code> Add a new column to an existing table. <code>DESCRIBE keyspace_name;</code> Display the schema and details of a keyspace. <code>DESCRIBE table_name;</code> Display the schema and details of a table. <code>SHOW VERSION;</code> Show the Cassandra version. <code>BEGIN BATCH;</code> Start a batch of CQL statements for atomic execution. <code>APPLY BATCH;</code> Execute a batch of CQL statements as a single atomic operation. <code>QUIT;</code> Exit the CQL shell."},{"location":"column/database-lab/","title":"Cassandra - Lab 1","text":"<p>In this lab session, we will explore Apache Cassandra by setting up a Docker Cassandra instance using the provided command. We will cover the following:</p> <ul> <li>Launching a Docker Cassandra Container</li> <li>Connecting to the Cassandra Cluster</li> <li>Creating a Keyspace and a Table</li> <li>Inserting and Querying Data</li> </ul>"},{"location":"column/database-lab/#1-starting-cassandra","title":"1. Starting Cassandra","text":""},{"location":"column/database-lab/#steps","title":"Steps","text":"<ol> <li>Start up Docker</li> <li>Open your Terminal</li> <li> <p>Execute the following command</p> <pre><code>docker run -d --name cassandra-instance -p 9042:9042 cassandra\n</code></pre> <p>Info</p> <p>This command creates a Docker container named \"cassandra-instance\" running the Cassandra image, maps port 9042 on your host to port 9042 inside the container, and runs Cassandra in the background.</p> </li> </ol>"},{"location":"column/database-lab/#expected-results","title":"Expected results","text":"<ul> <li>The terminal will show the container ID</li> </ul>"},{"location":"column/database-lab/#2-connecting-to-the-cassandra-cluster","title":"2. Connecting to the Cassandra Cluster","text":""},{"location":"column/database-lab/#steps_1","title":"Steps","text":"<ol> <li>Open the Terminal (or stay in the same Terminal window)</li> <li>Execute the following command</li> </ol> <pre><code>docker exec -it cassandra-instance cqlsh\n</code></pre>"},{"location":"column/database-lab/#expected-results_1","title":"Expected results","text":"<ul> <li> <p>The following information in the Terminal</p> <pre><code>Connected to Test Cluster at 127.0.0.1:9042\n[cqlsh 6.1.0 | Cassandra 4.1.3 | CQL spec 3.4.6 | Native protocol v5]\nUse HELP for help.\n</code></pre> </li> </ul>"},{"location":"column/database-lab/#3-create-a-namespace-and-a-table","title":"3. Create a namespace and a table","text":""},{"location":"column/database-lab/#steps_2","title":"Steps","text":"<ol> <li> <p>Create a namespace and a table where the namespace is called <code>people</code> and the table is nammed <code>person</code> by copying and pasting the following content in the CQL shell</p> <pre><code>CREATE KEYSPACE people WITH replication = {'class':'SimpleStrategy', 'replication_factor':1};\nUSE people;\n\nCREATE TABLE person (\n    id UUID PRIMARY KEY,\n    name TEXT,\n    age INT\n);\n</code></pre> </li> <li> <p>Run the folloiwing command in the CQL shell</p> <pre><code>describe people\n</code></pre> </li> </ol>"},{"location":"column/database-lab/#expected-results_2","title":"Expected results","text":"<ul> <li> <p>Namespace and table created, showing the following in the Terminal</p> <pre><code>CREATE KEYSPACE people WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}  AND durable_writes = true;\n\nCREATE TABLE people.person (\n    id uuid PRIMARY KEY,\n    age int,\n    name text\n) WITH additional_write_policy = '99p'\n    AND bloom_filter_fp_chance = 0.01\n    AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'}\n    AND cdc = false\n    AND comment = ''\n    AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'}\n    AND compression = {'chunk_length_in_kb': '16', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'}\n    AND memtable = 'default'\n    AND crc_check_chance = 1.0\n    AND default_time_to_live = 0\n    AND extensions = {}\n    AND gc_grace_seconds = 864000\n    AND max_index_interval = 2048\n    AND memtable_flush_period_in_ms = 0\n    AND min_index_interval = 128\n    AND read_repair = 'BLOCKING'\n    AND speculative_retry = '99p';\n</code></pre> </li> </ul>"},{"location":"column/database-lab/#4-inserting-data","title":"4. Inserting data","text":""},{"location":"column/database-lab/#steps_3","title":"Steps","text":"<ol> <li> <p>Run the following command in the CQL shell</p> <pre><code>INSERT INTO person (id, name, age) VALUES (uuid(), 'Alice', 30);\nINSERT INTO person (id, name, age) VALUES (uuid(), 'Bob', 25);\nINSERT INTO person (id, name, age) VALUES (uuid(), 'Charlie', 35);\n</code></pre> </li> <li> <p>Retrieve data from the <code>person</code> table running the following command in the CQL shell</p> <pre><code>SELECT * FROM person;\n</code></pre> </li> </ol>"},{"location":"column/database-lab/#expected-results_3","title":"Expected results","text":"<ul> <li> <p>The <code>person</code> data with this similar output</p> <pre><code> id                                  | age | name\n-------------------------------------+-----+---------\n4022c9af-4920-4787-8edb-8d1d8091ec30 |  30 |   Alice\nec3e9568-901e-41d4-af09-cae644d7d1a3 |  25 |     Bob\nbe51376c-d798-4234-ad8a-ba46e60b3131 |  35 | Charlie\n\n(3 rows)\n</code></pre> </li> </ul>"},{"location":"column/introduction/","title":"Introducion","text":"<p>Wide-column databases, a category within the NoSQL database family, have emerged as a pivotal solution to address the evolving needs of modern data management. Unlike traditional relational databases that rely on tables with rigid schemas, wide-column databases provide a flexible and scalable approach to handling vast amounts of data with varying structures. Due to several key factors, these databases have gained significant importance in the NoSQL world.</p>"},{"location":"column/introduction/#scalability-and-performance","title":"Scalability and Performance","text":"<p>Wide-column databases are designed for horizontal scalability, allowing them to distribute data across multiple nodes or clusters. This scalability is vital for applications dealing with massive datasets and high-throughput workloads, making them well-suited for web-scale and big-data scenarios.</p>"},{"location":"column/introduction/#schema-flexibility","title":"Schema Flexibility","text":"<p>Wide-column databases offer a schema-less or semi-structured data model, accommodating changes in data structures without the need for complex schema migrations. This adaptability is crucial for agile development and handling diverse data sources.</p>"},{"location":"column/introduction/#columnar-storage","title":"Columnar Storage","text":"<p>Data is stored in a columnar format rather than rows, enabling efficient data retrieval and query performance. This design is particularly advantageous for analytical and data warehousing use cases, as it minimizes I/O operations.</p>"},{"location":"column/introduction/#high-availability","title":"High Availability","text":"<p>Wide-column databases often employ distributed architectures and data replication, ensuring high availability and fault tolerance. This resilience is essential for mission-critical applications where downtime is not an option.</p>"},{"location":"column/introduction/#support-for-time-series-data","title":"Support for Time-Series Data","text":"<p>Wide-column databases excel at storing time-series data, making them an ideal choice for applications involving monitoring, IoT, financial analytics, and historical data analysis.</p>"},{"location":"column/introduction/#rich-query-capabilities","title":"Rich Query Capabilities","text":"<p>Many wide-column databases provide powerful query languages, allowing users to perform complex queries and analytics on large datasets. This capability is crucial for extracting insights and trends from data.</p>"},{"location":"column/introduction/#use-cases","title":"Use Cases","text":"<p>Wide-column databases are well-suited for various use cases, including content management systems, real-time analytics, customer relationship management (CRM), and time-series data storage. They empower applications to manage and query diverse data efficiently.</p>"},{"location":"column/introduction/#developer-productivity","title":"Developer Productivity","text":"<p>Developers can work with wide-column databases using familiar query languages and libraries, enhancing productivity and reducing the learning curve.</p> Use Case Description Time-Series Data Storage Wide-column databases excel at storing time-series data, making them a natural choice for applications involving the collection, storage, and analysis of time-stamped data points. This includes use cases in IoT, monitoring, log analysis, and financial markets, where tracking data changes over time is critical for insights and decision-making. Content Management Systems Wide-column databases are well-suited for content management systems (CMS) and digital asset management (DAM) applications. They efficiently store and manage structured and semi-structured content, such as articles, images, videos, and metadata. This flexibility allows content creators to add and update content without rigid schema constraints, accommodating diverse content types and formats. Real-Time Analytics Wide-column databases support real-time analytics by providing fast data retrieval and aggregation capabilities. They are used in applications that require rapid analysis of large volumes of data, such as e-commerce platforms tracking user behavior, social media platforms for monitoring trends, and ad tech platforms optimizing ad targeting based on user interactions."},{"location":"column/java-lab-2/","title":"Cassandra - Lab 3","text":"<p>In this lab, we will learn how to use Repository with Eclipse JNoSQL.</p>"},{"location":"column/java-lab-2/#1-define-the-repository-interface","title":"1. Define the Repository interface","text":""},{"location":"column/java-lab-2/#steps","title":"Steps","text":"<ol> <li>Create an interface called <code>PersonRepository</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate the interface with <code>@Repository</code> using the package from <code>jakarta.data.repository</code> to indicate it's a Jakarta Data repository</li> <li> <p>Extend the <code>CrudRepository</code> interface from the package <code>jakarta.data.repository</code> and specify the entity type (<code>Person</code>) and the ID type (<code>Long</code>) as type parameters. It defines the basic CRUD operations that can be performed on the <code>Person</code> entity</p> <pre><code>@Repository\npublic interface PersonRepository extends CrudRepository&lt;Person, Long&gt; {\n}\n</code></pre> </li> </ol>"},{"location":"column/java-lab-2/#expected-results","title":"Expected results","text":"<ul> <li>A repository class ready to perform database operations</li> </ul>"},{"location":"column/java-lab-2/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.data.repository.CrudRepository;\nimport jakarta.data.repository.Repository;\n\n@Repository\npublic interface PersonRepository extends CrudRepository&lt;Person, Long&gt; {\n}\n</code></pre>"},{"location":"column/java-lab-2/#2-create-the-execution-class-for-cassandra-repository","title":"2. Create the execution class for Cassandra Repository","text":""},{"location":"column/java-lab-2/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>AppCassandraRository</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Create two user instances using the builder of the <code>Person</code> class with different data inside the <code>try</code> statement</p> <pre><code>Person user1 = Person.builder()\n        .contacts(Map.of(\"twitter\", \"otaviojava\", \"linkedin\", \"otaviojava\",\"youtube\", \"otaviojava\"))\n        .name(\"Otavio Santana\").id(1).build();\n</code></pre> </li> <li> <p>Obtain an instance of the <code>PersonRepository</code> interface using Jakarta EE's <code>SeContainer</code>. It is done by selecting and getting an instance of the repository</p> <pre><code>PersonRepository repository = container.select(PersonRepository.class).get();\n</code></pre> </li> <li> <p>Save the user</p> <pre><code>repository.save(user1);\n</code></pre> </li> <li> <p>Retrieve data from the repository by <code>id</code> (1L) using the <code>findById</code> method where the result is wrapped in an <code>Optional</code> to handle the possibility of a non-existent entity</p> <pre><code>Optional&lt;Person&gt; person = repository.findById(1L);\n</code></pre> </li> <li> <p>Print the retrieved entity or indicate if it was not found</p> <pre><code>System.out.println(\"Entity found: \" + person);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppCassandraRepository</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppCassandraRepository() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"column/java-lab-2/#expected-results_1","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Entity found: Optional[Person{id=1, name='Otavio Santana', contacts={youtube=otaviojava, twitter=otaviojava, linkedin=otaviojava}}]\n</code></pre> </li> </ul>"},{"location":"column/java-lab-2/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class AppCassandraRepository {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Person user1 = Person.builder()\n                .contacts(Map.of(\"twitter\", \"otaviojava\", \"linkedin\", \"otaviojava\",\"youtube\", \"otaviojava\"))\n                .name(\"Otavio Santana\").id(1).build();\n\n            PersonRepository repository = container.select(PersonRepository.class).get();\n            repository.save(user1);\n\n            Optional&lt;Person&gt; person = repository.findById(1L);\n            System.out.println(\"Entity found: \" + person);\n        }\n    }\n\n    private AppCassandraRepository() {\n    }\n}\n</code></pre>"},{"location":"column/java-lab-3/","title":"Cassandra - Lab 4","text":"<p>In this lab, we will learn how to UDT.</p>"},{"location":"column/java-lab-3/#1-define-the-director-entity","title":"1. Define the <code>Director</code> Entity","text":""},{"location":"column/java-lab-3/#steps","title":"Steps","text":"<ol> <li>Create a class called <code>Director</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Define the class with the <code>@Entity</code> annotation</p> <pre><code>@Entity\npublic class Director {\n</code></pre> </li> <li> <p>Add the fields as specified in the provided code adding the<code>@Column</code> annotations for all</p> <pre><code>@Column\nprivate String name;\n\n@Column\nprivate Set&lt;String&gt; movies;\n</code></pre> </li> <li> <p>Implement constructors, setter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> method.</p> </li> </ol>"},{"location":"column/java-lab-3/#expected-results","title":"Expected results","text":"<ul> <li>Entity <code>Director</code> created</li> </ul>"},{"location":"column/java-lab-3/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\n\nimport java.util.Set;\n\n@Entity\npublic class Director {\n\n    @Column\n    private String name;\n\n    @Column\n    private Set&lt;String&gt; movies;\n\n    public Director() {\n    }\n\n    public Director(String name, Set&lt;String&gt; movies) {\n        this.name = name;\n        this.movies = movies;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setMovies(Set&lt;String&gt; movies) {\n        this.movies = movies;\n    }\n\n    @Override\n    public String toString() {\n        return \"Director{\" +\n            \"name='\" + name + '\\'' +\n            \", movies=\" + movies +\n            '}';\n    }\n}\n</code></pre>"},{"location":"column/java-lab-3/#2-implement-the-builder-class","title":"2. Implement the Builder class","text":""},{"location":"column/java-lab-3/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>DirectorBuilder</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add the same fields we had previously added to the <code>Director</code> class, without the annotations</p> <ul> <li>note that we need to initialize the <code>movies</code> attribute    </li> </ul> <pre><code>private String name;\nprivate final Set&lt;String&gt; movies = new HashSet&lt;&gt;();\n</code></pre> </li> <li> <p>Add the builder methods for each field</p> <ul> <li>for the <code>movies field</code>, add a single <code>movie</code> to the <code>Set</code></li> </ul> </li> <li>Add the <code>build()</code> method creating a new instance of <code>Director</code> using its constructor</li> <li>In the <code>Director</code> class add the builder method referring to the <code>DirectorBuilder</code></li> </ol>"},{"location":"column/java-lab-3/#expected-results_1","title":"Expected results","text":"<ul> <li>Builder class <code>DirectorBuilder</code> created</li> </ul>"},{"location":"column/java-lab-3/#solution_1","title":"Solution","text":"Click to see... <pre><code>import java.util.Set;\n\npublic class DirectorBuilder {\n\n    private String name;\n    private Set&lt;String&gt; movies;\n\n    public DirectorBuilder name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public DirectorBuilder addMovie(String movie) {\n        this.movies.add(movie)\n        return this;\n    }\n\n    public Director build() {\n        return new Director(name, movies);\n    }\n}\n</code></pre>"},{"location":"column/java-lab-3/#3-define-the-movie-entity","title":"3. Define the <code>Movie</code> Entity","text":""},{"location":"column/java-lab-3/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>Movie</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Define the class with the <code>@Entity</code> annotation</li> <li> <p>Define instance variables for <code>name</code>, <code>age</code>, and <code>director</code>, where the <code>name</code> is the ID and must have the <code>@Id</code> annotation and the other attributes the <code>@Column</code> annotation</p> <pre><code>@Id(\"name\")\nprivate String name;\n\n@Column\nprivate Integer age;\n\n@Column\nprivate Director director;\n</code></pre> </li> <li> <p>Annotate the <code>director</code> field with <code>@UDT(\"director\")</code> from the package <code>org.eclipse.jnosql.databases.cassandra.mapping</code> to specify that it's a User-Defined Type (UDT) with the name \"director\"</p> <pre><code>@Column\nUDT(\"director\")\nprivate Director director;\n</code></pre> </li> <li> <p>Implement the constructor, getter, setters, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods for the class</p> </li> </ol>"},{"location":"column/java-lab-3/#expected-results_2","title":"Expected results","text":"<ul> <li>Entity <code>Director</code> created</li> </ul>"},{"location":"column/java-lab-3/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\nimport org.eclipse.jnosql.databases.cassandra.mapping.UDT;\n\n@Entity\npublic class Movie {\n\n    @Id(\"name\")\n    private String name;\n\n    @Column\n    private Integer age;\n\n    @Column\n    @UDT(\"director\")\n    private Director director;\n\n    public Movie(String name, Integer age, Director director) {\n        this.name = name;\n        this.age = age;\n        this.director = director;\n    }\n\n    // getters and setters ignored\n\n    @Override\n    public String toString() {\n        return \"Movie{\" +\n            \"name='\" + name + '\\'' +\n            \", age=\" + age +\n            \", director=\" + director +\n            '}';\n    }\n}\n</code></pre>"},{"location":"column/java-lab-3/#4-define-the-movie-repository","title":"4. Define the <code>Movie</code> Repository","text":""},{"location":"column/java-lab-3/#steps_3","title":"Steps","text":"<ol> <li>Create an interface called <code>MovieRepository</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate the interface with <code>@Repository</code> using the package from <code>jakarta.data.repository</code> to indicate it's a Jakarta Data repository</li> <li> <p>Extend the <code>CassandraRepository</code> interface from the package <code>org.eclipse.jnosql.databases.cassandra.mapping</code> and specify the entity type (<code>Movie</code>) and the ID type (<code>String</code>) as type parameters</p> <pre><code>@Repository\npublic interface MovieRepository extends CassandraRepository&lt;Movie, String&gt; {\n}\n</code></pre> </li> <li> <p>Define the custom query <code>findByAge()</code></p> <pre><code>List&lt;Movie&gt; findByAge(Integer age);\n</code></pre> </li> <li> <p>Define a custom query <code>findAllQuery()</code> adding the <code>@CQL</code> annotation from the package <code>org.eclipse.jnosql.databases.cassandra.mapping</code> where its parameter have the following query <code>select * from developers.Movie</code></p> <pre><code>@CQL(\"select * from developers.Movie\")\nList&lt;Movie&gt; findAllQuery();\n</code></pre> </li> </ol>"},{"location":"column/java-lab-3/#expected-results_3","title":"Expected results","text":"<ul> <li>Repository <code>MovieRepository</code> containing two custom queries</li> </ul>"},{"location":"column/java-lab-3/#solution_3","title":"Solution","text":"Click to see... <pre><code>import jakarta.data.repository.Repository;\nimport org.eclipse.jnosql.databases.cassandra.mapping.CQL;\nimport org.eclipse.jnosql.databases.cassandra.mapping.CassandraRepository;\n\nimport java.util.List;\n\n@Repository\npublic interface MovieRepository extends CassandraRepository&lt;Movie, String&gt; {\n\n    List&lt;Movie&gt; findByAge(Integer age);\n\n    @CQL(\"select * from developers.Movie\")\n    List&lt;Movie&gt; findAllQuery();\n}\n</code></pre>"},{"location":"column/java-lab-3/#5-create-the-execution-class-for-cassandra-udt","title":"5. Create the execution class for Cassandra UDT","text":""},{"location":"column/java-lab-3/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>AppCassandraUDT</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain an instance of the <code>MovieRepository</code> interface using Jakarta EE's <code>SeContainer</code>. It is done by selecting and getting an instance of the repository</p> <pre><code>MovieRepository repository = container.select(MovieRepository.class).get();\n</code></pre> </li> <li> <p>Add the following <code>Movie</code> instances with its data</p> <pre><code>Movie matrix = new Movie();\nmatrix.setName(\"The Matrix\");\nmatrix.setAge(1999);\nmatrix.setDirector(Director.builder().name(\"Lana Wachowski\")\n    .add(\"The Matrix\").add(\"The Matrix Reloaded\").add(\"Assassins\").build());\n\nMovie fightClub = new Movie();\nfightClub.setName(\"Fight Club\");\nfightClub.setAge(1999);\nfightClub.setDirector(Director.builder().name(\"David Fincher\")\n    .add(\"Fight Club\").add(\"Seven\").add(\"The Social Network\").build());\n\nMovie americanBeauty = new Movie();\namericanBeauty.setName(\"American Beauty\");\namericanBeauty.setAge(1999);\namericanBeauty.setDirector(Director.builder().name(\"Sam Mendes\")\n    .add(\"Spectre\").add(\"SkyFall\").add(\"American Beauty\").build());\n</code></pre> </li> <li> <p>Use the repository to save all the created <code>Movie</code>, as a <code>List</code> of entities to Cassandra using <code>repository.saveAll()</code></p> <pre><code>repository.saveAll(List.of(matrix, fightClub, americanBeauty));\n</code></pre> </li> <li> <p>Retrieve and print all movies using <code>repository.findAllQuery()</code></p> <pre><code>List&lt;Movie&gt; allMovies = repository.findAllQuery();\nSystem.out.println(\"All movies = \" + allMovies);\n</code></pre> </li> <li> <p>Retrieve and print movies from the year 1999 using <code>repository.findByAge(1999)</code></p> <pre><code>List&lt;Movie&gt; movieByAge = repository.findByAge(1999);\nSystem.out.println(\"Movies from 1999 = \" + movieByAge);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppCassandraUDT</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppCassandraUDT() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"column/java-lab-3/#expected-results_4","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>All movies = [Movie{name='Fight Club', age=1999, director=Director{name='David Fincher', movies=[Fight Club, Seven, The Social Network]}}, Movie{name='American Beauty', age=1999, director=Director{name='Sam Mendes', movies=[American Beauty, SkyFall, Spectre]}}, Movie{name='The Matrix', age=1999, director=Director{name='Lana Wachowski', movies=[The Matrix, Assassins, The Matrix Reloaded]}}]\n\nMovies from 1999 = [Movie{name='Fight Club', age=1999, director=Director{name='David Fincher', movies=[Fight Club, Seven, The Social Network]}}, Movie{name='American Beauty', age=1999, director=Director{name='Sam Mendes', movies=[American Beauty, SkyFall, Spectre]}}, Movie{name='The Matrix', age=1999, director=Director{name='Lana Wachowski', movies=[The Matrix, Assassins, The Matrix Reloaded]}}]\n</code></pre> </li> </ul>"},{"location":"column/java-lab-3/#solution_4","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.util.List;\n\npublic class AppCassandraUDT {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            MovieRepository repository = container.select(MovieRepository.class).get();\n\n            Movie matrix = new Movie();\n            matrix.setName(\"The Matrix\");\n            matrix.setAge(1999);\n            matrix.setDirector(Director.builder().name(\"Lana Wachowski\")\n                .addMovie(\"The Matrix\").addMovie(\"The Matrix Reloaded\").addMovie(\"Assassins\").build());\n\n            Movie fightClub = new Movie();\n            fightClub.setName(\"Fight Club\");\n            fightClub.setAge(1999);\n            fightClub.setDirector(Director.builder().name(\"David Fincher\")\n                .addMovie(\"Fight Club\").add(\"Seven\").addMovie(\"The Social Network\").build());\n\n            Movie americanBeauty = new Movie();\n            americanBeauty.setName(\"American Beauty\");\n            americanBeauty.setAge(1999);\n            americanBeauty.setDirector(Director.builder().name(\"Sam Mendes\")\n                .addMovie(\"Spectre\").addMovie(\"SkyFall\").addMovie(\"American Beauty\").build());\n\n            repository.saveAll(List.of(matrix, fightClub, americanBeauty));\n\n            List&lt;Movie&gt; allMovies = repository.findAllQuery();\n            System.out.println(\"All movies = \" + allMovies);\n\n            List&lt;Movie&gt; movieByAge = repository.findByAge(1999);\n            System.out.println(\"Movies from 1999 = \" + movieByAge);\n        }\n    }\n\n    public AppCassandraUDT() {\n    }\n}\n</code></pre>"},{"location":"column/java-lab/","title":"Cassandra - Lab 2","text":""},{"location":"column/java-lab/#1-the-cassandra-structure","title":"1. The Cassandra structure","text":"<p>In this lab session, we will explore Apache Cassandra by executing various commands to create a keyspace, define column families, and create a secondary index.</p>"},{"location":"column/java-lab/#steps","title":"Steps","text":"<ol> <li> <p>Execute the following command in the CQL shell to create a keyspace named \"developers\" with a replication factor of 3</p> <pre><code>CREATE KEYSPACE IF NOT EXISTS developers WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};\n</code></pre> <p>Note</p> <p>You can ignore the warning that will be shown after running the command</p> <pre><code>Warnings :\nYour replication factor 3 for keyspace developers is higher than the number of nodes 1\n</code></pre> </li> <li> <p>Execute the following commands in the CQL shell to create column families for \"Person\" and \"Movie\"</p> <pre><code>CREATE COLUMNFAMILY IF NOT EXISTS developers.Person (id bigint PRIMARY KEY, name text, contacts map&lt;text, text&gt;);\nCREATE TYPE IF NOT EXISTS developers.director (name text, movies set&lt;text&gt;);\nCREATE COLUMNFAMILY IF NOT EXISTS developers.Movie (name text PRIMARY KEY, age int, director FROZEN&lt;director&gt;);\n</code></pre> </li> <li> <p>Create a secondary index on the \"age\" column of the \"Movie\" column family using the following command in the CQL shell</p> <pre><code>create index if not exists ageIndex on developers.movie(age);\n</code></pre> </li> <li> <p>Use the Cassandra shell to explore, insert, and query data within your instance</p> </li> </ol>"},{"location":"column/java-lab/#expected-results","title":"Expected results","text":"<ul> <li>Column families <code>movie</code> and <code>person</code> created</li> </ul>"},{"location":"column/java-lab/#2-implement-the-person-class","title":"2. Implement the <code>person</code> class","text":"<p>In this lab, we will learn how to create a Java connection with Cassandra.</p>"},{"location":"column/java-lab/#steps_1","title":"Steps","text":"<ol> <li>Open the <code>04-column</code> project and navigate to the <code>src/main/java</code></li> <li>Create a class called <code>Person</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Define the class with the <code>@Entity</code> annotation, specifying the entity name as \"Person.\"</p> <pre><code>@Entity(\"Person\")\npublic class Person {\n</code></pre> </li> <li> <p>Add the fields as specified in the provided code, including the <code>@Id</code> annotation for the <code>id</code> field and <code>@Column</code> annotations for the other fields.</p> <pre><code>@Id(\"id\")\nprivate long id;\n\n@Column\nprivate String name;\n\n@Column\nprivate Map&lt;String, String&gt; contacts;\n</code></pre> </li> <li> <p>Implement constructors, getter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods</p> </li> </ol>"},{"location":"column/java-lab/#expected-results_1","title":"Expected results","text":"<ul> <li>Entity <code>Person</code> created</li> </ul>"},{"location":"column/java-lab/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\nimport java.util.Map;\n\n@Entity\npublic class Person {\n\n    @Id(\"id\")\n    private long id;\n\n    @Column\n    private String name;\n\n    @Column\n    private Map&lt;String, String&gt; contacts;\n\n    public Person() {\n    }\n\n    public Person(long id, String name, Map&lt;String, String&gt; contacts) {\n        this.id = id;\n        this.name = name;\n        this.contacts = contacts;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Map&lt;String, String&gt; getContacts() {\n        return contacts;\n    }\n}\n</code></pre>"},{"location":"column/java-lab/#3-implement-the-builder-class","title":"3. Implement the Builder class","text":""},{"location":"column/java-lab/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>PersonBuilder</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add the same fields we had previously added to the <code>Person</code> class, without the annotations</p> <pre><code>private long id;\nprivate String name;\nprivate Map&lt;String, String&gt; contacts;\n</code></pre> </li> <li> <p>Add the builder methods for each field</p> </li> <li>Add the <code>build()</code> method creating a new instance of <code>Person</code> using its constructor</li> <li>In the <code>Person</code> class add the builder method referring to the <code>PersonBuilder</code></li> </ol>"},{"location":"column/java-lab/#solution_1","title":"Solution","text":"Click to see... <pre><code>import java.util.Map;\n\npublic class PersonBuilder {\n\n    private long id;\n    private String name;\n    private Map&lt;String, String&gt; contacts;\n\n    public PersonBuilder id(long id) {\n        this.id = id;\n        return this;\n    }\n\n    public PersonBuilder name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public PersonBuilder contacts(Map&lt;String, String&gt; contacts) {\n        this.contacts = contacts;\n        return this;\n    }\n\n    public Person build() {\n        return new Person(id, name, contacts);\n    }\n}\n</code></pre>"},{"location":"column/java-lab/#4-create-the-execution-class-for-basic-cassandra-operations","title":"4. Create the execution class for basic Cassandra Operations","text":""},{"location":"column/java-lab/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>AppCassandraOperations</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) throws InterruptedException {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Create two user instances using the builder of the <code>Person</code> class with different data inside the <code>try</code> statement</p> <pre><code>Person user1 = Person.builder()\n        .contacts(Map.of(\"twitter\", \"otaviojava\", \"linkedin\", \"otaviojava\",\"youtube\", \"otaviojava\"))\n        .name(\"Otavio Santana\").id(1).build();\n\nPerson user2 = Person.builder()\n        .contacts(Map.of(\"twitter\", \"elderjava\", \"linkedin\", \"elderjava\",\"youtube\", \"elderjava\"))\n        .name(\"Elder Moraes\").id(2).build();\n</code></pre> </li> <li> <p>Obtain an instance of <code>ColumnTemplate</code> using Jakarta EE's <code>SeContainer</code></p> <pre><code>ColumnTemplate template =  container.select(ColumnTemplate.class).get();\n</code></pre> </li> <li> <p>Insert, the two user instances into the column using the <code>ColumnTemplate</code>, where the second one will have a delay of 1 second, using the method <code>insert()</code></p> <pre><code>template.insert(user1);\ntemplate.insert(user2, Duration.ofSeconds(1));\n</code></pre> </li> <li> <p>Retrieve the <code>user2</code> data based on its <code>id</code> and printout the result</p> <ul> <li>use the method <code>select()</code> from the <code>template</code> field</li> <li>the first parameter is the class and the second is the <code>id</code> value</li> </ul> <pre><code>Optional&lt;Person&gt; person2 = template.find(Person.class, 2L);\nSystem.out.println(\"Person2 data: \" + person2);\n</code></pre> </li> <li> <p>Add a wait time, then retrieve and printout the same user again</p> <pre><code>TimeUnit.SECONDS.sleep(2L);\nperson2 = template.find(Person.class, 2L);\nSystem.out.println(\"Person2 second retrieve data: \" + person2);\n</code></pre> </li> <li> <p>Retrieve the <code>user1</code> data based on its <code>id</code> and printout the result</p> <pre><code>Optional&lt;User&gt; user1Data = template.get(\"user1\", User.class);\nSystem.out.println(\"User1 data: \" + user1Data);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppCassandraOperations</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppCassandraOperations() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"column/java-lab/#expected-results_2","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Person2 data: Optional[Person{id=2, name='Elder Moraes', contacts={youtube=elderjava, twitter=elderjava, linkedin=elderjava}}]\nPerson2 second retrieve data: Optional.empty\nPerson1 data: Optional[Person{id=1, name='Otavio Santana', contacts={youtube=otaviojava, twitter=otaviojava, linkedin=otaviojava}}]\n</code></pre> </li> <li> <p>The second printout, related to the <code>user2</code> does not show any data because it expired</p> </li> </ul>"},{"location":"column/java-lab/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport jakarta.nosql.column.ColumnTemplate;\n\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\n\npublic class AppCassandraOperations {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n\n            Person user1 = Person.builder()\n                .contacts(Map.of(\"twitter\", \"otaviojava\", \"linkedin\", \"otaviojava\", \"youtube\", \"otaviojava\"))\n                .name(\"Otavio Santana\").id(1).build();\n\n            Person user2 = Person.builder()\n                .contacts(Map.of(\"twitter\", \"elderjava\", \"linkedin\", \"elderjava\", \"youtube\", \"elderjava\"))\n                .name(\"Elder Moraes\").id(2).build();\n\n            ColumnTemplate template = container.select(ColumnTemplate.class).get();\n\n            template.insert(user1);\n            template.insert(user2, Duration.ofSeconds(1));\n\n            Optional&lt;Person&gt; person2 = template.find(Person.class, 2L);\n            System.out.println(\"Person2 data: \" + person2);\n\n            TimeUnit.SECONDS.sleep(2L);\n            person2 = template.find(Person.class, 2L);\n            System.out.println(\"Person2 second retrieve data: \" + person2);\n\n            Optional&lt;Person&gt; person1 = template.find(Person.class, 1L);\n            System.out.println(\"Person1 data: \" + person1);\n        }\n    }\n}\n</code></pre>"},{"location":"column/java-lab/#5-create-the-execution-class-for-cassandra-specialization","title":"5. Create the execution class for Cassandra specialization","text":"<p>In this lab, we will learn how to use specific features with Eclipse JNoSQL.</p>"},{"location":"column/java-lab/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>AppCassandraSpecialization</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Create a user instance using the builder of the <code>Person</code> class with some data inside the <code>try</code> statement</p> <pre><code>Person user1 = Person.builder().contacts(Map.of(\"twitter\", \"ada\")).name(\"Lovelace\").id(3).build();\n</code></pre> </li> <li> <p>Obtain an instance of <code>CassandraTemplate</code> using the <code>container.select()</code> method</p> <pre><code>CassandraTemplate template =  container.select(CassandraTemplate.class).get();\n</code></pre> </li> <li> <p>Save the <code>user1</code> person entity to Cassandra using a specified consistency level:</p> <pre><code>template.save(user1, ConsistencyLevel.ONE);\n</code></pre> </li> <li> <p>Retrieve data from Cassandra using a CQL query and collect the results into a list of <code>Person</code> objects:</p> <pre><code>List&lt;Person&gt; people = template.&lt;Person&gt;cql(\"select * from developers.Person where id = 1\")\n    .collect(Collectors.toList());\n</code></pre> </li> <li> <p>Print the retrieved entities:</p> <pre><code>System.out.println(people);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppCassandraSpecialization</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppCassandraSpecialization() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"column/java-lab/#expected-results_3","title":"Expected results","text":"<ul> <li>TBD</li> </ul>"},{"location":"column/java-lab/#solution_3","title":"Solution","text":"Click to see... <pre><code>import com.datastax.oss.driver.api.core.ConsistencyLevel;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.databases.cassandra.mapping.CassandraTemplate;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class AppCassandraSpecialization {\n\n    public static void main(String[] args) {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Person user1 = Person.builder().contacts(Map.of(\"twitter\", \"ada\")).name(\"Lovelace\").id(3).build();\n\n            CassandraTemplate template =  container.select(CassandraTemplate.class).get();\n            template.save(user1, ConsistencyLevel.ONE);\n\n            List&lt;Person&gt; people = template.&lt;Person&gt;cql(\"select * from developers.Person where id = 1\")\n                .collect(Collectors.toList());\n\n            System.out.println(people);\n        }\n    }\n\n    private AppCassandraSpecialization() {\n    }\n}\n</code></pre>"},{"location":"document/commands/","title":"MongoDB commands","text":"Command Description <code>use database_name;</code> Switches to a specific database for operations. <code>db.createCollection(\"collection_name\");</code> Creates a new collection within the current database. <code>db.collection_name.insertOne(document);</code> Inserts a single document into a collection. <code>db.collection_name.insertMany(documents);</code> Inserts multiple documents into a collection. <code>db.collection_name.find(query, projection);</code> Retrieves documents from a collection based on a query. <code>db.collection_name.updateOne(filter, update);</code> Updates a single document in a collection that matches the filter. <code>db.collection_name.updateMany(filter, update);</code> Updates multiple documents in a collection that match the filter. <code>db.collection_name.deleteOne(filter);</code> Deletes a single document from a collection that matches the filter. <code>db.collection_name.deleteMany(filter);</code> Deletes multiple documents from a collection that match the filter. <code>db.collection_name.aggregate(pipeline);</code> Performs aggregation operations on documents in a collection using a pipeline."},{"location":"document/database-lab/","title":"MongoDB - Lab 1","text":"<p>In this lab session, we will explore MongoDB by setting up a Docker MongoDB instance using the provided command. We will cover the following:</p> <ol> <li>Launching a Docker MongoDB Container</li> <li>Connecting to the MongoDB Instance using the MongoDB Shell (mongosh)</li> <li>Creating a Database and a Collection</li> <li>Inserting and Querying Documents</li> </ol>"},{"location":"document/database-lab/#1-starting-mongodb","title":"1. Starting MongoDB","text":""},{"location":"document/database-lab/#steps","title":"Steps","text":"<ol> <li>Start up Docker</li> <li>Open your Terminal</li> <li> <p>Execute the following command</p> <pre><code>docker run -d --name mongodb-instance -p 27017:27017 mongo\n</code></pre> <p>Info</p> <p>This command creates a Docker container named \"mongodb-instance\" running the MongoDB image, mapping port 27017 on your host to port 27017 inside the container, and running MongoDB in the background.</p> </li> </ol>"},{"location":"document/database-lab/#expected-results","title":"Expected results","text":"<ul> <li>The terminal will show the container ID</li> </ul>"},{"location":"document/database-lab/#2-connecting-to-the-mongodb-instance","title":"2. Connecting to the MongoDB Instance","text":""},{"location":"document/database-lab/#steps_1","title":"Steps","text":"<ol> <li>Open the Terminal (or stay in the same Terminal window)</li> <li>Execute the following command</li> </ol> <pre><code>docker exec -it mongodb-instance mongosh\n</code></pre>"},{"location":"document/database-lab/#expected-results_1","title":"Expected results","text":"<ul> <li> <p>The following information in the Terminal</p> <pre><code>Current Mongosh Log ID: 651983f1eda3dad76726cddf\nConnecting to:      URL to MongoDB\nUsing MongoDB:      7.0.1\nUsing Mongosh:      1.10.6\n</code></pre> </li> </ul>"},{"location":"document/database-lab/#3-create-a-database-and-a-collection","title":"3. Create a database and a collection","text":""},{"location":"document/database-lab/#steps_2","title":"Steps","text":"<ol> <li> <p>Create a database named <code>workspace</code> by running the following command in the MongoDB Shell</p> <pre><code>use workplace;\n</code></pre> </li> <li> <p>Create a collection called <code>people</code> by running the following command in the MongoDB Shell</p> <pre><code>db.createCollection(\"people\");\n</code></pre> </li> </ol>"},{"location":"document/database-lab/#expected-results_2","title":"Expected results","text":"<ul> <li> <p>Two logs in your Terminal related to the previous commands</p> <pre><code>switched to db workplace;\n{ ok: 1 }\n</code></pre> </li> </ul>"},{"location":"document/database-lab/#4-inserting-and-querying-documents","title":"4. Inserting and Querying Documents","text":""},{"location":"document/database-lab/#steps_3","title":"Steps","text":"<ol> <li> <p>Insert the following documents to the <code>people</code> collection, using the MongoDB Shell</p> <pre><code>db.people.insertOne({ name: \"Alice\", age: 30 });\n\ndb.people.insertMany([\n    { name: \"Bob\", age: 25 },\n    { name: \"Charlie\", age: 35 }\n]);\n</code></pre> </li> <li> <p>Query the documents, to prove that they were successfully inserted, by running the following command into the MondBD Shell</p> <pre><code>db.people.find();\n</code></pre> </li> </ol>"},{"location":"document/database-lab/#expected-results_3","title":"Expected results","text":"<ul> <li> <p>The following information in the Terminal</p> <pre><code>[\n    { _id: ObjectId(\"651985c0eda3dad76726cde0\"), name: 'Alice', age: 30 },\n    { _id: ObjectId(\"651985c1eda3dad76726cde1\"), name: 'Bob', age: 25 },\n    {\n        _id: ObjectId(\"651985c1eda3dad76726cde2\"),\n        name: 'Charlie',\n        age: 35\n    }\n]\n</code></pre> </li> </ul>"},{"location":"document/introduction/","title":"Introduction","text":"<p>Document databases represent a pivotal innovation in NoSQL databases, addressing modern applications' evolving data management needs. Unlike traditional relational databases that rely on structured tables, document databases store and manage data in a flexible, schema-less format, typically using JSON or BSON documents. This approach has gained immense importance in the NoSQL landscape for several compelling reasons.</p> <ol> <li> <p>Schema Flexibility: Document databases embrace schema flexibility, allowing developers to store data without predefined schemas. This flexibility is vital for accommodating diverse and evolving data structures in today's applications.</p> </li> <li> <p>Simplified Data Modeling: Developers can represent complex data structures naturally using documents, mirroring the data's real-world structure. It simplifies data modeling and reduces impedance mismatches between application code and database schema.</p> </li> <li> <p>Scalability: Document databases are designed for horizontal scalability, allowing organizations to scale by distributing data across multiple nodes or clusters. It ensures high performance and accommodates growing workloads.</p> </li> <li> <p>High Read and Write Throughput: Document databases are optimized for high read and write Throughput, making them suitable for real-time applications and use cases requiring rapid data ingestion and retrieval.</p> </li> <li> <p>Support for Semi-Structured Data: Many modern applications use semi-structured or hierarchical data. Document databases excel at handling such data, providing nested documents and arrays for structured representation.</p> </li> <li> <p>Query Flexibility: Document databases offer flexible querying capabilities, enabling developers to retrieve data using various criteria, including fields within documents. This versatility is vital for ad-hoc queries and complex data access patterns.</p> </li> <li> <p>JSON/BSON Format: Documents are typically stored in JSON or BSON format, making them human-readable and compatible with various programming languages and frameworks. It promotes ease of development and integration.</p> </li> <li> <p>Use Cases: Document databases are well-suited for many use cases, including content management systems, e-commerce platforms, catalogs, user profiles, IoT data storage, and more. Their versatility allows organizations to use a single database technology for diverse application needs.</p> </li> <li> <p>Developer Productivity: Developers can work with document databases using familiar data structures and query languages, reducing the learning curve and enhancing productivity.</p> </li> <li> <p>Agile Development: Document databases align well with agile development practices, enabling developers to iterate quickly, adapt to changing requirements, and introduce new features without being constrained by rigid schemas.</p> </li> </ol> Use Case Description Content Management Systems Ideal for CMS and DAM systems to manage structured and unstructured content, including articles, images, videos, and metadata. Catalogs and Product Listings Used in e-commerce platforms for storing product catalogs with flexible document representations. User Profiles and Personalization Efficiently store user profiles and personalization data, enabling tailored user experiences. Internet of Things (IoT) Data Efficiently manage time-series data generated by IoT sensors and devices. Real-Time Analytics Suitable for real-time analytics, data ingestion, processing, and complex querying for insights. Content-Based Searching Supports full-text search capabilities, making it ideal for searching within large datasets. User-Generated Content Beneficial for social media platforms and user-driven websites to store posts, comments, and media uploads. Event Logging and Audit Trails Valuable for recording events, actions, and auditing, including timestamps and user IDs. Data Integration and Aggregation Centralizes data integration and aggregation from multiple sources for reporting and analytics. Collaborative Tools Used in collaborative project management software and document editors for efficient collaboration and version tracking."},{"location":"document/java-lab-2/","title":"MongoDB - Lab 3","text":"<p>In this lab, you will create a Java application that utilizes Jakarta Data's repository framework to manage a library of books. The application will allow you to save books, retrieve books by title, and perform pageable queries on the book data. </p>"},{"location":"document/java-lab-2/#1-define-the-library-repository-interface","title":"1. Define the Library Repository Interface","text":""},{"location":"document/java-lab-2/#steps","title":"Steps","text":"<ol> <li> <p>Create an interface called <code>Library</code> and annotate it with <code>@Repository</code> from the <code>jakarta.data.repository</code> package</p> <pre><code>@Repository\npublic interface Library {\n}\n</code></pre> </li> <li> <p>Extend the <code>PageableRepository&lt;Book, String&gt;</code> interface, specifying that it's a repository for managing <code>Book</code> entities with <code>String</code> as the type of the ID field</p> <pre><code>@Repository\npublic interface Library extends PageableRepository&lt;Book, String&gt; {\n}\n</code></pre> </li> <li> <p>Define a custom query method <code>findByTitle()</code> that will take a <code>title</code> as <code>String</code> where the return is a <code>List</code> of <code>Book</code></p> <pre><code>List&lt;Book&gt; findByTitle(String title);\n</code></pre> </li> </ol>"},{"location":"document/java-lab-2/#expected-results","title":"Expected results","text":"<ul> <li>Entity <code>Library</code> created</li> </ul>"},{"location":"document/java-lab-2/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.data.repository.PageableRepository;\nimport jakarta.data.repository.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface Library extends PageableRepository&lt;Book, String&gt; {\n\n    List&lt;Book&gt; findByTitle(String title);\n}\n</code></pre>"},{"location":"document/java-lab-2/#2-add-a-factory-data-method-to-book","title":"2. Add a factory data method to <code>Book</code>","text":""},{"location":"document/java-lab-2/#steps_1","title":"Steps","text":"<ol> <li>Open the <code>Book</code> class</li> <li> <p>Add the following method</p> <pre><code>public static Book of(Faker faker) {\n    return new Book(faker.code().isbn13(), faker.book().title(), faker.number().numberBetween(1, 10),\n        faker.number().numberBetween(1900, 2022));\n}\n</code></pre> <p>Note</p> <p>The method <code>of()</code> will take the <code>Faker</code> class that's from the DataFaker library to generate random data when its accessed.</p> </li> </ol>"},{"location":"document/java-lab-2/#expected-results_1","title":"Expected results","text":"<ul> <li>Class <code>Book</code> with an additional method to generate its instance using random data</li> </ul>"},{"location":"document/java-lab-2/#solution_1","title":"Solution","text":"Click to see... <pre><code>import com.github.javafaker.Faker;\nimport jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\n@Entity\npublic record Book(@Id String isbn, @Column String title, @Column int edition, @Column int year) {\n\n    public static Book of(Faker faker) {\n        return new Book(faker.code().isbn13(), faker.book().title(), faker.number().numberBetween(1, 10),\n            faker.number().numberBetween(1900, 2022));\n    }\n}\n</code></pre>"},{"location":"document/java-lab-2/#3-create-the-execution-class-to-insert-data","title":"3. Create the execution class to insert data","text":""},{"location":"document/java-lab-2/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>AppMongoDBPagable</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Using the Jakarta SE container, obtain an instance of the <code>Library</code> repository by selecting it: <code>container.select(Library.class).get()</code></p> <pre><code>Library library = container.select(Library.class).get();\n</code></pre> </li> <li> <p>Instantiate the <code>Faker</code> class to be able to, later on, save the book with some data</p> <pre><code>Faker faker = new Faker();\n</code></pre> </li> <li> <p>Create a look saving 100 different books using the <code>libary.save()</code> method</p> <pre><code>IntStream.range(0, 100).mapToObj(index -&gt; Book.of(faker)).forEach(library::save);\n</code></pre> </li> <li> <p>Create a <code>Pageable</code> object named <code>pageable</code> using <code>Pageable.ofSize(10).sortBy(Sort.asc(\"title\"), Sort.desc(\"year\"))</code>. This sets options for retrieving books in pages of size 10, sorted by title in ascending order and year in descending order</p> <ul> <li>both <code>Pageable</code> and <code>Sort</code> classes are from the <code>jakarta.data.repository</code> package</li> </ul> <pre><code>Pageable pageable = Pageable.ofSize(10).sortBy(Sort.asc(\"title\"), Sort.desc(\"year\"));\n</code></pre> </li> <li> <p>Find all books on the filter we created above, which will contain 10 entries, using the <code>Page</code> class from <code>jakarta.data.repository</code> package</p> <pre><code>Page&lt;Book&gt; page = library.findAll(pageable);\n</code></pre> </li> <li> <p>Printout the content of the <code>page</code> attribute using the <code>content()</code> method</p> <pre><code>System.out.println(\"Page = \" + page.content());\n</code></pre> </li> <li> <p>Create a second <code>Pageable</code> object named <code>nextPage</code> to retrieve the next page of books</p> <pre><code>Pageable nextPage = pageable.next();\n</code></pre> </li> <li> <p>Find all books from the next page</p> <pre><code>Page&lt;Book&gt; page2 = library.findAll(nextPage);\n</code></pre> </li> <li> <p>Printout the content of the <code>page2</code> attribute using the <code>content()</code> method</p> <pre><code>System.out.println(\"Page 2 = \" + page2);\n</code></pre> </li> <li> <p>Use the custom query <code>findByTitle()</code> to find the book \"Effective Java\" and printout the result</p> <pre><code>library.findByTitle(\"Effective Java\").forEach(System.out::println);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppMongoDBPagable</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppMongoDBPagable() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"document/java-lab-2/#expected-results_2","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Page = [Book[isbn=2fc4801f-fbed-4878-9e85-538487feae65, title=Effective Java, edition=1, year=2019], Book[isbn=9790753509363, title=If Not Now, When?, edition=5, year=2017], Book[isbn=9780972389006, title=Fran\u00e7oise Sagan, edition=4, year=2016], Book[isbn=9781430782025, title=The Little Foxes, edition=9, year=2012], Book[isbn=9790835585384, title=If Not Now, When?, edition=6, year=2010], Book[isbn=9780771303333, title=The World, the Flesh and the Devil, edition=7, year=2009], Book[isbn=9791077784467, title=To Sail Beyond the Sunset, edition=9, year=2008], Book[isbn=9780705967556, title=That Hideous Strength, edition=3, year=2006], Book[isbn=9790949723771, title=An Instant In The Wind, edition=5, year=2006], Book[isbn=9781470218720, title=The Violent Bear It Away, edition=7, year=2005]]\n\nPage 2 = NoSQLPage{entities=[Book[isbn=9781470218720, title=The Violent Bear It Away, edition=7, year=2005], Book[isbn=9780878082858, title=Where Angels Fear to Tread, edition=3, year=2003], Book[isbn=9791962492460, title=The Moon by Night, edition=4, year=2002], Book[isbn=9780736251754, title=East of Eden, edition=4, year=2002], Book[isbn=9781087074238, title=Nectar in a Sieve, edition=8, year=2001], Book[isbn=9790880353556, title=To Say Nothing of the Dog, edition=4, year=2001], Book[isbn=9781884451362, title=Clouds of Witness, edition=8, year=2000], Book[isbn=9791584073665, title=Have His Carcase, edition=3, year=2000], Book[isbn=9781961487482, title=The Wind's Twelve Quarters, edition=7, year=1999], Book[isbn=9790332536162, title=Edna O'Brien, edition=9, year=1998]], pageable=Pageable{page=2, size=10, title ASC, year DESC}}\n\nBook[isbn=2fc4801f-fbed-4878-9e85-538487feae65, title=Effective Java, edition=1, year=2019]\n</code></pre> </li> </ul>"},{"location":"document/java-lab-2/#solution_2","title":"Solution","text":"Click to see... <pre><code>import com.github.javafaker.Faker;\nimport jakarta.data.repository.Page;\nimport jakarta.data.repository.Pageable;\nimport jakarta.data.repository.Sort;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.util.stream.IntStream;\n\npublic class AppMongoDBPagable {\n\n    public static void main(String[] args) {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Library library = container.select(Library.class).get();\n\n\n            Faker faker = new Faker();\n            IntStream.range(0, 100).mapToObj(index -&gt; Book.of(faker)).forEach(library::save);\n\n            Pageable pageable = Pageable.ofSize(10).sortBy(Sort.asc(\"title\"), Sort.desc(\"year\"));\n            Page&lt;Book&gt; page = library.findAll(pageable);\n            System.out.println(\"Page = \" + page.content());\n\n            Pageable nextPage = pageable.next();\n            Page&lt;Book&gt; page2 = library.findAll(nextPage);\n            System.out.println(\"Page 2 = \" + page2);\n\n            library.findByTitle(\"Effective Java\").forEach(System.out::println);\n        }\n    }\n\n    private AppMongoDBPagable() {\n    }\n}\n</code></pre>"},{"location":"document/java-lab-3/","title":"MongoDB - Lab 4","text":"<p>In this lab, you will create Java classes that model an Author entity along with related classes for building Author objects, representing addresses, and describing jobs. These classes will be used to interact with a NoSQL database using Jakarta NoSQL and Jakarta EE. Below are the step-by-step instructions for creating these classes</p>"},{"location":"document/java-lab-3/#1-define-the-address-embeddable-class","title":"1. Define the <code>Address</code> Embeddable Class","text":""},{"location":"document/java-lab-3/#steps","title":"Steps","text":"<ol> <li>Create a class called <code>Address</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate it using the <code>@Embeddable</code> from the <code>org.eclipse.jnosql.mapping</code> package</li> <li> <p>Add two attributes: <code>city</code> and <code>street</code> and use the <code>@Column</code> annotation, both as <code>String</code></p> <pre><code>@Column\nprivate String street;\n\n@Column\nprivate String city;\n</code></pre> </li> <li> <p>Implement constructors, getter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods</p> </li> </ol>"},{"location":"document/java-lab-3/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport org.eclipse.jnosql.mapping.Embeddable;\n\n@Embeddable\npublic class Address {\n\n    @Column\n    private String street;\n\n    @Column\n    private String city;\n\n    public Address() {\n    }\n\n    public Address(String street, String city) {\n        this.street = street;\n        this.city = city;\n    }\n\n    // other method ignored\n}    \n</code></pre>"},{"location":"document/java-lab-3/#2-define-the-job-embeddable-class","title":"2. Define the <code>Job</code> Embeddable Class","text":""},{"location":"document/java-lab-3/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>Job</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate it using the <code>@Embeddable</code> from the <code>org.eclipse.jnosql.mapping</code> package</li> <li> <p>Add two attibutes: <code>salary</code> and <code>occupation</code> and use the <code>@Column</code> annotation, where <code>salary</code> is a <code>double</code> and <code>occupation</code> a <code>String</code></p> <pre><code>@Column\nprivate double salary;\n\n@Column\nprivate String occupation;\n</code></pre> </li> <li> <p>Implement constructors, getter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods</p> </li> </ol>"},{"location":"document/java-lab-3/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport org.eclipse.jnosql.mapping.Embeddable;\n\n@Embeddable\npublic class Job {\n\n    @Column\n    private double salary;\n\n    @Column\n    private String occupation;\n\n    public Job() {\n    }\n\n    public Job(double salary, String occupation) {\n        this.salary = salary;\n        this.occupation = occupation;\n    }\n\n    // other method ignored\n}    \n</code></pre>"},{"location":"document/java-lab-3/#3-define-the-author-entity-class","title":"3. Define the <code>Author</code> Entity Class","text":""},{"location":"document/java-lab-3/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>Author</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Define the class with the <code>@Entity</code> annotation from the <code>jakarta.nosql</code> package</li> <li> <p>Add the following fields in in the record:</p> Annotation Type Name <code>@Id</code> <code>Long</code> <code>id</code> <code>@Colum</code> <code>String</code> <code>name</code> <code>@Colum</code> <code>List&lt;String&gt;</code> <code>phones</code> <code>@Colum</code> <code>Address</code> <code>address</code> <code>@Colum</code> <code>Job</code> <code>job</code> </li> <li> <p>Implement constructors, getter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods </p> </li> </ol>"},{"location":"document/java-lab-3/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\nimport java.util.List;\n\n@Entity\npublic class Author {\n\n    @Id\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Column\n    private List&lt;String&gt; phones;\n\n    @Column\n    private Address address;\n\n    @Column\n    private Job job;\n\n    public Author() {\n    }\n\n    public Author(Long id, String name, List&lt;String&gt; phones, Address address, Job job) {\n        this.id = id;\n        this.name = name;\n        this.phones = phones;\n        this.address = address;\n        this.job = job;\n    }\n\n    // other method ignored\n}  \n</code></pre>"},{"location":"document/java-lab-3/#4-implement-the-builder-class","title":"4. Implement the Builder class","text":""},{"location":"document/java-lab-3/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>AuthorBuilder</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add the same fields we had previously added to the <code>Author</code> class, without the annotations</p> <pre><code>private long id;\nprivate String name;\nprivate List&lt;String&gt; phones;\nprivate Address address;\nprivate Job job;\n</code></pre> </li> <li> <p>Add the builder methods for each field</p> </li> <li>Add the <code>build()</code> method creating a new instance of <code>Author</code> using its constructor</li> <li>In the <code>Author</code> class add the builder method referring to the <code>AuthorBuilder</code></li> </ol>"},{"location":"document/java-lab-3/#solution_3","title":"Solution","text":"Click to see... <pre><code>import java.util.List;\n\npublic class AuthorBuilder {\n\n    private long id;\n\n    private String name;\n\n    private List&lt;String&gt; phones;\n\n    private Address address;\n\n    private Job job;\n\n    public AuthorBuilder id(long id) {\n        this.id = id;\n        return this;\n    }\n\n    public AuthorBuilder name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public AuthorBuilder phones(List&lt;String&gt; phones) {\n        this.phones = phones;\n        return this;\n    }\n\n    public AuthorBuilder address(Address address) {\n        this.address = address;\n        return this;\n    }\n\n    public AuthorBuilder job(Job job) {\n        this.job = job;\n        return this;\n    }\n\n    public Author build() {\n        return new Author(id, name, phones, address, job);\n    }\n}\n</code></pre>"},{"location":"document/java-lab-3/#5-create-the-execution-class","title":"5. Create the execution class","text":""},{"location":"document/java-lab-3/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>AppMongoDBSubdocuments</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Create a <code>ThreadLocalRandom</code> instance and get the next value, associating it to an attribute</p> <pre><code>ThreadLocalRandom random = ThreadLocalRandom.current();\nlong id = random.nextLong();\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Create a new instance of <code>Faker</code></p> <pre><code>Faker faker = new Faker();\n</code></pre> </li> <li> <p>Create a new instance of the <code>Author</code> class using <code>faker</code> to provide data</p> <pre><code>Address address = new Address(faker.address().streetName(), faker.address().city());\n</code></pre> </li> <li> <p>Create a new instance of the <code>Job</code> class using <code>faker</code> to provide data</p> <pre><code>Job job = new Job(12.12, faker.job().title());\n</code></pre> </li> <li> <p>Create a new instance of the <code>Author</code> class using <code>faker</code> to provide data</p> <pre><code>Author author = Author.builder()\n    .phones(Arrays.asList(faker.phoneNumber().cellPhone(), faker.phoneNumber().cellPhone()))\n    .name(faker.name().fullName()).address(address).job(job).id(id).build();\n</code></pre> </li> <li> <p>Obtain a <code>DocumentTemplate</code> instance from <code>jakarta.nosql.document</code> package by selecting it: <code>container.select(DocumentTemplate.class).get()</code></p> <pre><code>DocumentTemplate template = container.select(DocumentTemplate.class).get();\n</code></pre> </li> <li> <p>Use the <code>DocumentTemplate</code> to insert the <code>Author</code> instance into the NoSQL database and retrieve the saved author</p> <pre><code>Author saved = template.insert(author);\n</code></pre> </li> <li> <p>Printout the saved author</p> <pre><code>System.out.println(\"Author saved = \" + saved);\n</code></pre> </li> <li> <p>Use the <code>DocumentTemplate</code> to perform a query to retrieve authors by the city in their address</p> <pre><code>List&lt;Author&gt; people = template.select(Author.class).where(\"address.city\").eq(address.getCity()).result();\n</code></pre> </li> <li> <p>Printout the result</p> <pre><code>System.out.println(\"Entities found: \" + people);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppCassandraOperations</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppMongoDBSubdocuments() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method    </p> </li> </ol>"},{"location":"document/java-lab-3/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Author saved = Author{id=-5926041563979906242, name='Marissa Koch Jr.', phones=[347-971-6761, 1-199-518-8887], address=Address{street='Roselee Ports', city='Stantonport'}, job=Job{salary=12.12, occupation='Legal Assistant'}}\n\nEntities found: [Author{id=-5926041563979906242, name='Marissa Koch Jr.', phones=[347-971-6761, 1-199-518-8887], address=Address{street='Roselee Ports', city='Stantonport'}, job=Job{salary=12.12, occupation='Legal Assistant'}}]\n</code></pre> </li> </ul>"},{"location":"document/java-lab-3/#solution_4","title":"Solution","text":"Click to see... <pre><code>import com.github.javafaker.Faker;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport jakarta.nosql.document.DocumentTemplate;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class AppMongoDBSubdocuments {\n\n    public static void main(String[] args) {\n        ThreadLocalRandom random = ThreadLocalRandom.current();\n        long id = random.nextLong();\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Faker faker = new Faker();\n\n            Address address = new Address(faker.address().streetName(), faker.address().city());\n            Job job = new Job(12.12, faker.job().title());\n            Author author = Author.builder()\n                .phones(Arrays.asList(faker.phoneNumber().cellPhone(), faker.phoneNumber().cellPhone()))\n                .name(faker.name().fullName()).address(address).job(job).id(id).build();\n\n            DocumentTemplate template = container.select(DocumentTemplate.class).get();\n\n            Author saved = template.insert(author);\n            System.out.println(\"Author saved = \" + saved);\n\n            List&lt;Author&gt; people = template.select(Author.class).where(\"address.city\").eq(address.getCity()).result();\n            System.out.println(\"Entities found: \" + people);\n        }\n    }\n\n    private AppMongoDBSubdocuments() {\n    }\n}\n</code></pre>"},{"location":"document/java-lab-4/","title":"MongoDB - Lab 4","text":"<p>In this lab, you will create Java classes for defining a repository interface and a main application class. The repository interface (<code>AuthorRepository</code>) will extend <code>PageableRepository</code> for data access, and the main application (<code>App4</code>) will demonstrate how to use this repository to interact with a NoSQL database using Jakarta Data. Below are the step-by-step instructions for creating these classes:</p>"},{"location":"document/java-lab-4/#1-define-the-authorrepository-interface","title":"1. Define the <code>AuthorRepository</code> Interface","text":""},{"location":"document/java-lab-4/#steps","title":"Steps","text":"<ol> <li>Create an <code>interface</code> called <code>AuthorRepository</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate it with <code>@Repository</code> from the <code>jakarta.data.repository</code> package</li> <li> <p>Extends the interface with the <code>PageableRepository</code> using the <code>Author</code> class and <code>Long</code></p> <pre><code>@Repository\npublic interface AuthorRepository extends PageableRepository&lt;Author, Long&gt; {\n}\n</code></pre> </li> <li> <p>Add a custom query to find the author by name</p> <pre><code> List&lt;Author&gt; findByName(String name);\n</code></pre> </li> <li> <p>Add a custom query to find a phone number</p> <pre><code>Stream&lt;Author&gt; findByPhones(String phone);\n</code></pre> </li> </ol>"},{"location":"document/java-lab-4/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.data.repository.PageableRepository;\nimport jakarta.data.repository.Repository;\n\nimport java.util.List;\nimport java.util.stream.Stream;\n\n@Repository\npublic interface AuthorRepository extends PageableRepository&lt;Author, Long&gt; {\n\n    List&lt;Author&gt; findByName(String name);\n\n    Stream&lt;Author&gt; findByPhones(String phone);\n}\n</code></pre>"},{"location":"document/java-lab-4/#2-create-the-execution-class","title":"2. Create the execution class","text":""},{"location":"document/java-lab-4/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>AppMongoDBSubdocumentRepository</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Create a <code>ThreadLocalRandom</code> instance and get the next value, associating it to an attribute</p> <pre><code>ThreadLocalRandom random = ThreadLocalRandom.current();\nlong id = random.nextLong();\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Create a new instance of <code>Faker</code></p> <pre><code>Faker faker = new Faker();\n</code></pre> </li> <li> <p>Create a new instance of the <code>Author</code> class using <code>faker</code> to provide data</p> <pre><code>Address address = new Address(faker.address().streetName(), faker.address().city());\n</code></pre> </li> <li> <p>Create a new instance of the <code>Job</code> class using <code>faker</code> to provide data</p> <pre><code>Job job = new Job(12.12, faker.job().title());\n</code></pre> </li> <li> <p>Create a new instance of the <code>Author</code> class using <code>faker</code> to provide data</p> <pre><code>Author author = Author.builder()\n    .phones(Arrays.asList(faker.phoneNumber().cellPhone(), faker.phoneNumber().cellPhone()))\n    .name(faker.name().fullName()).address(address).job(job).id(id).build();\n</code></pre> </li> <li> <p>Obtain an instance of the <code>AuthorRepository</code> from the Jakarta SE container by selecting it: <code>container.select(AuthorRepository.class).get()</code></p> <pre><code>AuthorRepository template = container.select(AuthorRepository.class).get();\n</code></pre> </li> <li> <p>Use the <code>AuthorRepository</code> to save the <code>Author</code> instance into the NoSQL database</p> <pre><code>template.save(author);\n</code></pre> </li> <li> <p>Query the authors by name</p> <pre><code>List&lt;Author&gt; authorByName = template.findByName(author.getName());\n</code></pre> </li> <li> <p>Printout the result</p> <pre><code>System.out.println(\"Author by name = \" + authorByName);\n</code></pre> </li> <li> <p>Retrieve the same author by it's phone number</p> <pre><code>List&lt;Author&gt; list = template.findByPhones(author.getPhones().get(0)).toList();\n</code></pre> </li> <li> <p>Printout the result</p> <pre><code>System.out.println(\"Author's phone = \" + list);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppMongoDBSubdocumentRepository</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppMongoDBSubdocuments() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method    </p> </li> </ol>"},{"location":"document/java-lab-4/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Author by name = [Author{id=-6736921736259877587, name='Edward Koch', phones=[1-267-083-3844, (367) 346-8130], address=Address{street='Jin Ports', city='North Alysebury'}, job=Job{salary=12.12, occupation='IT Consultant'}}]\n\nAuthor's phone = [Author{id=-6736921736259877587, name='Edward Koch', phones=[1-267-083-3844, (367) 346-8130], address=Address{street='Jin Ports', city='North Alysebury'}, job=Job{salary=12.12, occupation='IT Consultant'}}]\n</code></pre> </li> </ul>"},{"location":"document/java-lab-4/#solution_1","title":"Solution","text":"Click to see... <pre><code>import com.github.javafaker.Faker;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class AppMongoDBSubdocumentRepository {\n\n    public static void main(String[] args) {\n\n        ThreadLocalRandom random = ThreadLocalRandom.current();\n        long id = random.nextLong();\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Faker faker = new Faker();\n\n            Address address = new Address(faker.address().streetName(), faker.address().city());\n            Job job = new Job(12.12, faker.job().title());\n            Author author = Author.builder()\n                .phones(Arrays.asList(faker.phoneNumber().cellPhone(), faker.phoneNumber().cellPhone()))\n                .name(faker.name().fullName())\n                .address(address)\n                .job(job)\n                .id(id).build();\n\n            AuthorRepository template = container.select(AuthorRepository.class).get();\n            template.save(author);\n\n            List&lt;Author&gt; authorByName = template.findByName(author.getName());\n            System.out.println(\"Author by name = \" + authorByName);\n\n            List&lt;Author&gt; list = template.findByPhones(author.getPhones().get(0)).toList();\n            System.out.println(\"Author's phone = \" + list);\n        }\n    }\n\n    private AppMongoDBSubdocumentRepository() {\n    }\n}\n</code></pre>"},{"location":"document/java-lab/","title":"MongoDB - Lab 2","text":"<p>In this lab, you will create a Java application that interacts with a NoSQL database using Jakarta NoSQL and Jakarta EE. The application will define an entity class <code>Book</code> to represent books and use a <code>DocumentTemplate</code> to perform database operations. </p>"},{"location":"document/java-lab/#1-define-the-book-entity-class","title":"1. Define the <code>Book</code> Entity Class","text":""},{"location":"document/java-lab/#steps","title":"Steps","text":"<ol> <li>Open the <code>05-document</code> project and navigate to the <code>src/main/java</code></li> <li>Create a <code>record</code> called <code>Book</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Define the class with the <code>@Entity</code> annotation from the <code>jakarta.nosql</code> package</li> <li>Add the following fields in the record:<ul> <li><code>@Id String isbn</code></li> <li><code>@Column String title</code></li> <li><code>@Column int edition</code></li> <li><code>@Column int year</code></li> </ul> </li> </ol>"},{"location":"document/java-lab/#expected-results","title":"Expected results","text":"<ul> <li>Record <code>Book</code> created</li> </ul>"},{"location":"document/java-lab/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\n@Entity\npublic record Book(@Id String isbn, @Column String title, @Column int edition, @Column int year) {\n}\n</code></pre>"},{"location":"document/java-lab/#2-create-the-execution-class-to-insert-data","title":"2. Create the execution class to insert data","text":""},{"location":"document/java-lab/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>AppMongoDB</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Create an instance of the <code>Book</code> class with some sample data. You can use <code>UUID.randomUUID().toString()</code> for the <code>isbn</code>, \"Effective Java\" for the title, <code>1</code> for the edition, and <code>2019</code> for the year. inside the <code>try</code> statement</p> <pre><code>Book book = new Book(UUID.randomUUID().toString(), \"Effective Java\", 1, 2019);\n</code></pre> </li> <li> <p>Obtain a <code>DocumentTemplate</code> instance from the package <code>jakarta.nosql.document</code> using the Jakarta SE container by selecting it: <code>container.select(DocumentTemplate.class).get()</code></p> <pre><code>DocumentTemplate template = container.select(DocumentTemplate.class).get();\n</code></pre> </li> <li> <p>Use the <code>DocumentTemplate</code> to insert the <code>book</code> instance into the NoSQL database</p> <pre><code>Book saved = template.insert(book);\n</code></pre> </li> <li> <p>Printout the content of the book inserted</p> <pre><code>System.out.println(\"Book saved: = \" + saved);\n</code></pre> </li> <li> <p>Use the <code>DocumentTemplate</code> to perform a query to retrieve a book by its title</p> <pre><code>Optional&lt;Book&gt; bookFound = template.select(Book.class).where(\"title\").eq(\"Effective Java\").singleResult();\n</code></pre> </li> <li> <p>Printout the result</p> </li> </ol> <pre><code>System.out.println(\"bookFound = \" + bookFound);\n</code></pre> <ol> <li> <p>Define a private constructor for the <code>AppMongoDB</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppMongoDB() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"document/java-lab/#expected-results_1","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Book saved: = Book[isbn=2fc4801f-fbed-4878-9e85-538487feae65, title=Effective Java, edition=1, year=2019]\n\nBook Found = Optional[Book[isbn=2fc4801f-fbed-4878-9e85-538487feae65, title=Effective Java, edition=1, year=2019]]\n</code></pre> </li> </ul>"},{"location":"document/java-lab/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport jakarta.nosql.document.DocumentTemplate;\n\nimport java.util.Optional;\nimport java.util.UUID;\n\npublic class AppMongoDb {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Book book = new Book(UUID.randomUUID().toString(), \"Effective Java\", 1, 2019);\n\n            DocumentTemplate template = container.select(DocumentTemplate.class).get();\n            Book saved = template.insert(book);\n            System.out.println(\"Book saved: = \" + saved);\n\n            Optional&lt;Book&gt; bookFound = template.select(Book.class).where(\"title\").eq(\"Effective Java\").singleResult();\n            System.out.println(\"Book Found = \" + bookFound);\n        }\n    }\n\n    private AppMongoDb() {\n    }\n}\n</code></pre>"},{"location":"document/mongodb/","title":"MongoDB Overview","text":"<p>MongoDB is a leading NoSQL database management system that revolutionizes storing, retrieving, and working with data. Unlike traditional relational databases, MongoDB adopts a flexible document-oriented approach, where data is stored in BSON (Binary JSON) documents. This schema-less design allows for seamless handling of unstructured and semi-structured data, making it well-suited for modern applications that demand agility and scalability. MongoDB's robust querying capabilities, horizontal scalability, and real-time data processing capabilities have made it a go-to choice for many applications, from content management systems and e-commerce platforms to IoT data storage and real-time analytics. Its adaptability and developer-friendly features empower organizations to efficiently manage and leverage data in today's fast-paced, data-driven world.</p>"},{"location":"document/mongodb/#main-features","title":"Main features","text":"<ol> <li> <p>Flexible Document Model: MongoDB stores data in flexible, JSON-like BSON (Binary JSON) documents, allowing you to represent complex, hierarchical data structures without rigid schemas.</p> </li> <li> <p>Dynamic Schema: Unlike traditional databases, MongoDB's schema can evolve, making it well-suited for agile development and accommodating changing data requirements.</p> </li> <li> <p>Highly Scalable: MongoDB supports horizontal scaling through sharding, allowing you to distribute data across multiple servers and handle large datasets and high traffic loads.</p> </li> <li> <p>Replication: MongoDB provides automated data replication for high availability and fault tolerance, ensuring that your data remains accessible even during server failures.</p> </li> <li> <p>Flexible Indexing: MongoDB offers flexible indexing options to optimize query performance, including compound indexes, geospatial indexes, and text indexes.</p> </li> <li> <p>Powerful Query API: MongoDB's query API supports a wide range of query types, including range queries, regular expressions, and geospatial queries, enabling complex data retrieval.</p> </li> <li> <p>Aggregation Framework: MongoDB's aggregation framework allows you to perform advanced data transformations and aggregations, making it suitable for real-time analytics and reporting.</p> </li> <li> <p>Security Features: MongoDB offers robust security features, including authentication, authorization, and role-based access control, to protect your data and applications.</p> </li> <li> <p>Geospatial Capabilities: MongoDB supports geospatial data and queries, making it ideal for location-based applications and services.</p> </li> <li> <p>Rich Ecosystem: MongoDB's rich ecosystem includes drivers and libraries for various programming languages, integrations with popular tools and frameworks, and a strong developer community, facilitating easy integration and development.</p> </li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/","title":"Jakarta CDI - After Intermediate Lab 1","text":"<p>In this lab, we will explore the CDI decorator using Workers as the sample, and we will decorate it with a manager.</p>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#1-create-the-loggerproducer-class","title":"1. Create the <code>LoggerProducer</code> class","text":""},{"location":"extra-labs/cdi-lab-after-intermediate-1/#steps","title":"Steps","text":"<ol> <li>Create a new package called <code>decorator</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li>Create an interface called <code>Worker</code></li> <li>Create the <code>worker</code> method which will set a <code>job</code></li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#solution","title":"Solution","text":"Click to see... <pre><code>public interface Worker {\n\n    String work(String job);\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#2-create-the-programmer-class","title":"2. Create the <code>Programmer</code> Class","text":"<ol> <li>Create a class called <code>Programmer</code> in the <code>expert.os.labs.persistence.cid.decorator</code> package</li> <li>Implements <code>Worker</code> and the method <code>work()</code><ul> <li>the <code>Consumer</code> class is from the <code>java.util.function</code> package</li> </ul> </li> <li>Define a private attribute <code>Logger</code> from the <code>java.util.logging</code> package</li> <li>In the method <code>work()</code>, return a <code>String</code> based on its job</li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\n\nimport java.util.logging.Logger;\n\n@ApplicationScoped\npublic class Programmer implements Worker {\n\n    private static final Logger LOGGER = Logger.getLogger(Programmer.class.getName());\n\n    @Override\n    public String work(String job) {\n        return \"A programmer has received a job, it will convert coffee in code: \" + job;\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#3-create-the-manager-class-decorator","title":"3. Create the <code>Manager</code> Class (Decorator)","text":""},{"location":"extra-labs/cdi-lab-after-intermediate-1/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>Manager</code> in the <code>expert.os.labs.persistence.cid.decorator</code> package</li> <li>Implements the <code>Worker</code> interface</li> <li>Annotate the class with <code>@Decorator</code> from the <code>jakarta.decorator</code> package</li> <li>Add a priority to the decorator using the <code>@Priority</code> from the <code>jakarta.annotation</code> package<ul> <li>the priority must be set as <code>Interceptor.Priority.APPLICATION</code></li> </ul> </li> <li>Add a private field <code>Worker</code> annotating it with:<ul> <li><code>@Inject</code> from the <code>jakarta.inject</code> package</li> <li><code>@Delegate</code> from the <code>jakarta.decorator</code> package</li> <li><code>@Any</code> from the <code>jakarta.enterprise.inject</code> package</li> </ul> </li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.annotation.Priority;\nimport jakarta.decorator.Decorator;\nimport jakarta.decorator.Delegate;\nimport jakarta.enterprise.inject.Any;\nimport jakarta.inject.Inject;\nimport jakarta.interceptor.Interceptor;\n\n@Decorator\n@Priority(Interceptor.Priority.APPLICATION)\npublic class Manager implements Worker {\n\n    @Inject\n    @Delegate\n    @Any\n    private Worker worker;\n\n    @Override\n    public String work(String job) {\n        return \"A manager has received a job and it will delegate to a programmer -&gt; \" + worker.work(job);\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#6-create-the-app-class","title":"6. Create the app class","text":""},{"location":"extra-labs/cdi-lab-after-intermediate-1/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>AppWorker</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain the value of the <code>Worker</code> through the container instance</p> </li> <li>Define a work from the <code>worker</code> instance</li> <li>Printout the work</li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>&lt;the output you defined&gt;\n</code></pre> </li> </ul>"},{"location":"extra-labs/cdi-lab-after-intermediate-1/#solution_3","title":"Solution","text":"Click to see... <pre><code>import expert.os.labs.persistence.cdi.decorator.Worker;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\npublic class AppWorker {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Worker worker = container.select(Worker.class).get();\n\n            String work = worker.work(\"Just a single button\");\n            System.out.println(\"The work result: \" + work);\n        }\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/","title":"Jakarta CDI - After Intermediate Lab 2","text":"<p>In this lab, we will explore the CDI interceptor, creating a timer for methods.</p>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#1-create-a-timed-annotation","title":"1. Create a <code>Timed</code> annotation","text":"<ol> <li>Create a new package called <code>audited</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li>Create an interface called <code>Timed</code> in the <code>expert.os.labs.persistence.cid.audited</code> package</li> <li>Annotate the interface as <code>@interface</code></li> <li>Add the following annotations:<ul> <li><code>@InterceptorBinding</code> from the <code>jakarta.interceptor</code> package</li> <li><code>@Target({METHOD, TYPE})</code><ul> <li>the <code>@Target</code> is from the <code>java.lang.annotation</code> package</li> <li>the <code>METHOD</code> and <code>TYPE</code> is from the <code>java.lang.annotation.ElementType</code> package</li> </ul> </li> <li><code>@Retention(RUNTIME)</code><ul> <li>the <code>@Retention</code> is from the <code>java.lang.annotation</code> package</li> <li>the <code>RUNTIME</code> is from the <code>java.lang.annotation.ElementType</code> package</li> </ul> </li> </ul> </li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.interceptor.InterceptorBinding;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n@InterceptorBinding\n@Target({METHOD, TYPE})\n@Retention(RUNTIME)\npublic @interface Timed {\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#2-create-the-timedinterceptor-class","title":"2. Create the <code>TimedInterceptor</code> Class","text":""},{"location":"extra-labs/cdi-lab-after-intermediate-2/#steps","title":"Steps","text":"<ol> <li>Create a class called <code>TimedInterceptor</code> in the <code>expert.os.labs.persistence.cid.audited</code> package</li> <li>Add the following annotations:<ul> <li><code>@Timed</code></li> <li><code>@Interceptor</code> from the <code>jakarta.interceptor</code> package</li> <li><code>@Priority(Interceptor.Priority.APPLICATION)</code> from the <code>jakarta.annotation</code> package<ul> <li>the <code>Interceptor</code> is from the <code>jakarta.interceptor</code> package</li> </ul> </li> </ul> </li> <li>Define a private attribute <code>Logger</code> from the <code>java.util.logging</code> package</li> <li>Create a method called <code>timer</code> that will return an <code>Object</code><ul> <li>it has a parameter <code>InvocationContext</code> from the <code>jakarta.interceptor</code> package</li> </ul> </li> <li>Annotate the method with <code>@AroundInvoke</code> from the <code>jakarta.interceptor</code> package</li> <li>In the <code>timer()</code> method, add:<ul> <li>the current time into a variable using the <code>System.currentTimeMillis()</code></li> <li>the next interceptor using <code>ctx.proceed();</code>, associating it to an object</li> <li>the time slapsed into a variale (<code>System.currentTimeMillis() - start</code>)</li> <li>the information about the time slapsed into a <code>String</code> showing it using <code>ctx.getTarget().getClass(), ctx.getMethod(), end</code></li> <li>Log the content of the information using the logger</li> <li>return the information</li> </ul> </li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.annotation.Priority;\nimport jakarta.interceptor.AroundInvoke;\nimport jakarta.interceptor.Interceptor;\nimport jakarta.interceptor.InvocationContext;\n\nimport java.util.logging.Logger;\n\n@Timed\n@Interceptor\n@Priority(Interceptor.Priority.APPLICATION)\npublic class TimedInterceptor {\n\n    private static final Logger LOGGER = Logger.getLogger(TimedInterceptor.class.getName());\n\n    @AroundInvoke\n    public Object timer(InvocationContext ctx) throws Exception {\n        long start = System.currentTimeMillis();\n        Object result = ctx.proceed();\n        long end = System.currentTimeMillis() - start;\n\n        String message = String.format(\"Time to execute the class %s, the method %s is %d milliseconds\",\n            ctx.getTarget().getClass(), ctx.getMethod(), end);\n        LOGGER.info(message);\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#3-create-the-fastsupplier-class","title":"3. Create the <code>FastSupplier</code> Class","text":""},{"location":"extra-labs/cdi-lab-after-intermediate-2/#steps_1","title":"Steps","text":"<ol> <li>Create a class <code>FastSupplier</code> in the in the <code>expert.os.labs.persistence.cid.audited</code> package</li> <li>Implement the <code>Supplier&lt;String&gt;</code></li> <li>Annotate the method <code>get()</code> with <code>@Timed</code></li> <li>Return any <code>String</code></li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#solution_2","title":"Solution","text":"Click to see... <pre><code>import java.util.function.Supplier;\n\npublic class FastSupplier implements Supplier&lt;String&gt; {\n\n    @Timed\n    @Override\n    public String get() {\n        return \"The Fast supplier result\";\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#4-create-the-slowsupplier-class","title":"4. Create the <code>SlowSupplier</code> Class","text":""},{"location":"extra-labs/cdi-lab-after-intermediate-2/#steps_2","title":"Steps","text":"<ol> <li>Create a class <code>SlowSupplier</code> in the in the <code>expert.os.labs.persistence.cid.audited</code> package</li> <li>Implement the <code>Supplier&lt;String&gt;</code></li> <li>Annotate the method <code>get()</code> with <code>@Timed</code></li> <li> <p>Add the following code to the method</p> <pre><code>try {\n    TimeUnit.MILLISECONDS.sleep(200L);\n} catch (InterruptedException e) {\n    //TODO it is only a sample, don't do it on production :)\n    throw  new RuntimeException(e);\n}\nreturn \"The slow result\";\n</code></pre> </li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#solution_3","title":"Solution","text":"Click to see... <pre><code>import java.util.concurrent.TimeUnit;\nimport java.util.function.Supplier;\n\npublic class SlowSupplier implements Supplier&lt;String&gt; {\n\n    @Timed\n    @Override\n    public String get() {\n        try {\n            TimeUnit.MILLISECONDS.sleep(200L);\n        } catch (InterruptedException e) {\n            //TODO it is only a sample, don't do it on production :)\n            throw  new RuntimeException(e);\n        }\n        return \"The slow result\";\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#5-create-the-app-class","title":"5. Create the app class","text":""},{"location":"extra-labs/cdi-lab-after-intermediate-2/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>AppInterceptor</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain the value of the <code>FastSupplier</code> through the container instance</p> </li> <li>Obtain the value of the <code>SlowSupplier</code> through the container instance</li> <li>Printout both results</li> </ol>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>INFO: Time to execute the class class expert.os.labs.persistence.cdi.audited.FastSupplier$Proxy$_$$_WeldSubclass, the method public java.lang.String expert.os.labs.persistence.cdi.audited.FastSupplier.get() is 0 milliseconds\nThe result: The Fast supplier result\n\nINFO: Time to execute the class class expert.os.labs.persistence.cdi.audited.SlowSupplier$Proxy$_$$_WeldSubclass, the method public java.lang.\n\nString expert.os.labs.persistence.cdi.audited.SlowSupplier.get() is 203 milliseconds\nThe result: The slow result    \n</code></pre> </li> </ul>"},{"location":"extra-labs/cdi-lab-after-intermediate-2/#solution_4","title":"Solution","text":"Click to see... <pre><code>import expert.os.labs.persistence.cdi.audited.FastSupplier;\nimport expert.os.labs.persistence.cdi.audited.SlowSupplier;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.util.function.Supplier;\n\npublic class AppInterceptor {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Supplier&lt;String&gt; fastSupplier = container.select(FastSupplier.class).get();\n            Supplier&lt;String&gt; slowSupplier = container.select(SlowSupplier.class).get();\n\n            System.out.println(\"The result: \" + fastSupplier.get());\n            System.out.println(\"The result: \" + slowSupplier.get());\n        }\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-1/","title":"Jakarta CDI - Intermediate Lab 1","text":"<p>In this lab, we will create an object and destroy objects using the Produces and Dispose annotations, respectively.</p>"},{"location":"extra-labs/cdi-lab-intermediate-1/#1-create-the-numberproducer-class","title":"1. Create the <code>NumberProducer</code> class","text":""},{"location":"extra-labs/cdi-lab-intermediate-1/#steps","title":"Steps","text":"<ol> <li>Open the <code>01-jakarta-ee</code> project and navigate to the <code>src/main/java</code></li> <li>Create a package named <code>producer</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li>Create a class called <code>NumberProducer</code> in the <code>expert.os.labs.persistence.cid.producer</code> package</li> <li>Annotate it with the <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li>Add a producer method, annotating it with <code>@Produces</code> from the <code>jakarta.enterprise.inject</code> package and generate a random <code>BigDecimal</code> value within the range [1, 100] using the <code>ThreadLocalRandom</code> and return it</li> <li>Add a disposer method named <code>destroy()</code> to remove the value from the class where it has a <code>value</code> parameter annotated with <code>@Disposes</code> from the <code>jakarta.enterprise.inject</code> package</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-1/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.inject.Disposes;\nimport jakarta.enterprise.inject.Produces;\n\nimport java.math.BigDecimal;\nimport java.util.concurrent.ThreadLocalRandom;\n\n@ApplicationScoped\npublic class NumberProducer {\n\n    @Produces\n    public BigDecimal producer() {\n        ThreadLocalRandom random = ThreadLocalRandom.current();\n        double nextDouble = random.nextInt(1, 100);\n        return new BigDecimal(nextDouble);\n    }\n\n    public void destroy(@Disposes BigDecimal value) {\n        System.out.println(\"We don't need this number anymore: \" + value);\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-1/#2-create-the-app-class","title":"2. Create the app class","text":""},{"location":"extra-labs/cdi-lab-intermediate-1/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>AppNumber</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain the value of the <code>BigDecimal</code> through the container instance</p> </li> <li>Printout the value</li> <li>Run the <code>main()</code> method</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-1/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Value = &lt;number&gt;\nWe don't need this number anymore: &lt;number&gt;\n</code></pre> <p>Note</p> <p>The <code>destroy()</code> method is used as a disposer method for <code>BigDecimal</code> instances. It takes a parameter of type <code>BigDecimal</code> annotated with <code>@Disposes</code>. When an instance of <code>BigDecimal</code> is no longer needed, the CDI container will automatically call this method to perform cleanup or logging. In this case, it prints a message indicating that the number is no longer needed.</p> <p>In summary, this code defines an application-scoped CDI bean (<code>NumberProducer</code>) that produces random <code>BigDecimal</code> values using a producer method. It also includes a disposer method to handle the cleanup of <code>BigDecimal</code> instances when they are no longer needed within the CDI context.</p> </li> </ul>"},{"location":"extra-labs/cdi-lab-intermediate-1/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.math.BigDecimal;\n\npublic class AppNumber {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            BigDecimal value = container.select(BigDecimal.class).get();\n            System.out.println(\"Value = \" + value);\n        }\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-2/","title":"Jakarta CDI - Intermediate Lab 2","text":"<p>In this lab, we will create an object taking information from who needs this information using the InjectionPoint. Thus, we will create a Logger producer.</p>"},{"location":"extra-labs/cdi-lab-intermediate-2/#1-create-the-loggerproducer-class","title":"1. Create the <code>LoggerProducer</code> class","text":""},{"location":"extra-labs/cdi-lab-intermediate-2/#steps","title":"Steps","text":"<ol> <li>Create a class called <code>LoggerProducer</code> in the <code>expert.os.labs.persistence.cid.producer</code> package</li> <li>Create a constant to log results using the <code>Logger</code> from the <code>java.util.logging</code> package</li> <li>Annotate it with the <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li>Add a producer method, annotating it with <code>@Produces</code> from the <code>jakarta.enterprise.inject</code> where:<ul> <li>it has a parameter using the <code>InjectionPoint</code> class from <code>jakarta.enterprise.inject.spi</code> package</li> <li>get the class name using the Injection point, associating it with a variable</li> <li>log the class name using the logger</li> </ul> </li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-2/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.inject.Produces;\nimport jakarta.enterprise.inject.spi.InjectionPoint;\n\nimport java.util.logging.Logger;\n\n@ApplicationScoped\npublic class LoggerProducer {\n\n    private static final Logger LOGGER = Logger.getLogger(LoggerProducer.class.getName());\n\n    @Produces\n    Logger getLog(InjectionPoint injectionPoint) {\n        String declaringClass = injectionPoint.getMember().getDeclaringClass().getName();\n        LOGGER.info(\"Creating instance log to \" + declaringClass);\n\n        return Logger.getLogger(declaringClass);\n    }\n}\n</code></pre> <p>Note</p> <p>The <code>getLog()</code> method is annotated with <code>@Produces</code>, indicating that it is a CDI producer method. This method produces <code>java.util.logging.Logger</code> instances. It takes an <code>InjectionPoint</code> as a parameter, which provides information about the injection point. It retrieves the declaring class name from the injection point and creates a <code>Logger</code> instance for that class name. It also logs a message indicating the creation of the logger.</p>"},{"location":"extra-labs/cdi-lab-intermediate-2/#2-define-a-class-that-uses-the-produced-logger","title":"2. Define a class that uses the produced logger","text":""},{"location":"extra-labs/cdi-lab-intermediate-2/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>NumberLogger</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li>Define a private attribute <code>Logger</code> from the <code>java.util.logging</code> package</li> <li>Add a default constructor</li> <li>Add a constructor that receives the <code>Logger</code> as a parameter and annotate it using the <code>@Inject</code> class from the <code>jakarta.inject</code> package</li> <li>Add a log method to log a <code>BigDecimal</code> value</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-2/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.inject.Inject;\n\nimport java.math.BigDecimal;\nimport java.util.logging.Logger;\n\npublic class NumberLogger {\n\n    private Logger logger;\n\n    NumberLogger() {\n    }\n\n    @Inject\n    public NumberLogger(Logger logger) {\n        this.logger = logger;\n    }\n\n    public void log(BigDecimal value) {\n        this.logger.info(\"The BigDecimal value is \" + value);\n    }\n\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-2/#3-create-the-app-class","title":"3. Create the app class","text":""},{"location":"extra-labs/cdi-lab-intermediate-2/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>AppNumberLog</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain the value of the <code>BigDecimal</code> through the container instance</p> </li> <li>Obtain the value of the <code>NumberLogger</code> through the container instance</li> <li>Printout the value of the <code>NumberLogger</code></li> <li>Run the <code>main()</code> method</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-2/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>expert.os.labs.persistence.cdi.producer.LoggerProducer getLog\nINFO: Creating instance log to expert.os.labs.persistence.cdi.NumberLogger\nexpert.os.labs.persistence.cdi.NumberLogger log\nINFO: The BigDecimal value is 11\nWe don't need this number anymore: 11\n</code></pre> </li> </ul>"},{"location":"extra-labs/cdi-lab-intermediate-2/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.math.BigDecimal;\n\npublic class AppNumberLog {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            BigDecimal value = container.select(BigDecimal.class).get();\n\n            NumberLogger logger = container.select(NumberLogger.class).get();\n            logger.log(value);\n        }\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-3/","title":"Jakarta CDI - Intermediate Lab 3","text":"<p>In this lab, we will explore more about the CDI events.</p>"},{"location":"extra-labs/cdi-lab-intermediate-3/#1-create-the-loggerproducer-class","title":"1. Create the <code>LoggerProducer</code> class","text":""},{"location":"extra-labs/cdi-lab-intermediate-3/#steps","title":"Steps","text":"<ol> <li>Create a new package called <code>news</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li>Create the class <code>News</code> in the <code>expert.os.labs.persistence.cid.news</code></li> <li>Implements the <code>Supplier&lt;String&gt;</code> interface and it's method <code>get()</code></li> <li>Add a private <code>String</code> field named <code>name</code></li> <li>Create a constructor to associate its name</li> <li>Add a factory method <code>of()</code> that will create a new instance of <code>News</code></li> <li>Make the <code>get()</code> method return the value of the <code>name</code> attribute</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-3/#solution","title":"Solution","text":"Click to see... <pre><code>public final class News implements Supplier&lt;String&gt; {\n\n    private String name;\n\n    public News(String name) {\n        this.name = name;\n    }\n\n    public static News of(String news) {\n        return new News(news);\n    }\n\n    @Override\n    public String get() {\n        return name;\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-3/#2-create-the-magazine-class","title":"2. Create the <code>MAgazine</code> class","text":""},{"location":"extra-labs/cdi-lab-intermediate-3/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>Magazine</code> in the <code>expert.os.labs.persistence.cid.news</code> package</li> <li>Implements the <code>Consumer&lt;News&gt;</code> and the method <code>accept()</code><ul> <li>the <code>Consumer</code> class is from the <code>java.util.function</code> package</li> </ul> </li> <li>Define a private attribute <code>Logger</code> from the <code>java.util.logging</code> package</li> <li>Add the <code>@Observes</code> annotation to the <code>News</code> attribute in the <code>accept()</code> method, where it's from the <code>jakarta.enterprise.event</code> package</li> <li>Log the <code>News</code> in the <code>accept()</code> method</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-3/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.event.Observes;\n\nimport java.util.function.Consumer;\nimport java.util.logging.Logger;\n\npublic class Magazine implements Consumer&lt;News&gt; {\n\n    private static final Logger LOGGER = Logger.getLogger(Magazine.class.getName());\n\n    @Override\n    public void accept(@Observes News news) {\n        LOGGER.info(\"We got the news, we'll publish it on a magazine: \" + news.get());\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-3/#3-create-the-newspaper-class","title":"3. Create the <code>NewsPaper</code> class","text":""},{"location":"extra-labs/cdi-lab-intermediate-3/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>NewsPapper</code> in the <code>expert.os.labs.persistence.cid.news</code> package</li> <li>Annotate it with <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li>Implements the <code>Consumer&lt;News&gt;</code> and the method <code>accept()</code><ul> <li>the <code>Consumer</code> class is from the <code>java.util.function</code> package</li> </ul> </li> <li>Define a private attribute <code>Logger</code> from the <code>java.util.logging</code> package</li> <li>Add the <code>@Observes</code> annotation to the <code>News</code> attribute in the <code>accept()</code> method, where it's from the <code>jakarta.enterprise.event</code> package</li> <li>Log the <code>News</code> in the <code>accept()</code> method</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-3/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.event.Observes;\n\nimport java.util.function.Consumer;\nimport java.util.logging.Logger;\n\n@ApplicationScoped\npublic class NewsPaper implements Consumer&lt;News&gt; {\n\n    private static final Logger LOGGER = Logger.getLogger(NewsPaper.class.getName());\n\n    @Override\n    public void accept(@Observes News news) {\n        LOGGER.info(\"We got the news, we'll publish it on a newspaper: \" + news.get());\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-3/#4-create-the-socialmedia-class","title":"4. Create the <code>SocialMedia</code> class","text":""},{"location":"extra-labs/cdi-lab-intermediate-3/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>SocialMedia</code> in the <code>expert.os.labs.persistence.cid.news</code> package</li> <li>Annotate it with <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li>Implements the <code>Consumer&lt;News&gt;</code> and the method <code>accept()</code><ul> <li>the <code>Consumer</code> class is from the <code>java.util.function</code> package</li> </ul> </li> <li>Define a private attribute <code>Logger</code> from the <code>java.util.logging</code> package</li> <li>Add the <code>@Observes</code> annotation to the <code>News</code> attribute in the <code>accept()</code> method, where it's from the <code>jakarta.enterprise.event</code> package</li> <li>Log the <code>News</code> in the <code>accept()</code> method</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-3/#solution_3","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.event.Observes;\n\nimport java.util.function.Consumer;\nimport java.util.logging.Logger;\n\n@ApplicationScoped\npublic class SocialMedia implements Consumer&lt;News&gt; {\n\n    private static final Logger LOGGER = Logger.getLogger(SocialMedia.class.getName());\n\n    @Override\n    public void accept(@Observes News news) {\n        LOGGER.info(\"We got the news, we'll publish it on Social Media: \" + news.get());\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-3/#5-create-the-journalist-class","title":"5. Create the <code>Journalist</code> class","text":""},{"location":"extra-labs/cdi-lab-intermediate-3/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>Journalist</code> in the <code>expert.os.labs.persistence.cid.news</code> package</li> <li>Annotate it with <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li>Create a private <code>Event&lt;News&gt;</code> field and annotate it with <code>@Inject</code> from <code>jakarta.inject</code> package<ul> <li>The <code>Event</code> is from the <code>jakarta.enterprise.event</code> package</li> </ul> </li> <li>Create a method named <code>receiveNews</code> with a <code>News</code> parameter which will fire and event (<code>this.event.fire()</code>)</li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-3/#solution_4","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.event.Event;\nimport jakarta.inject.Inject;\n\n@ApplicationScoped\npublic class Journalist {\n\n    @Inject\n    private Event&lt;News&gt; event;\n\n    public void receiveNews(News news) {\n        this.event.fire(news);\n    }\n}\n</code></pre>"},{"location":"extra-labs/cdi-lab-intermediate-3/#6-create-the-app-class","title":"6. Create the app class","text":""},{"location":"extra-labs/cdi-lab-intermediate-3/#steps_5","title":"Steps","text":"<ol> <li>Create a class called <code>AppJournalist</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain the value of the <code>Journalist</code> through the container instance</p> </li> <li>Printout the news using the method <code>receiveNews</code> from the <code>Journalist</code> using the <code>News.of()</code></li> </ol>"},{"location":"extra-labs/cdi-lab-intermediate-3/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>INFO: We got the news, we'll publish it on Social Media: &lt;the news you defined&gt;\n</code></pre> </li> </ul>"},{"location":"extra-labs/cdi-lab-intermediate-3/#solution_5","title":"Solution","text":"Click to see... <pre><code>import expert.os.labs.persistence.cdi.news.Journalist;\nimport expert.os.labs.persistence.cdi.news.News;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\npublic class AppJournalist {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Journalist journalist = container.select(Journalist.class).get();\n            journalist.receiveNews(News.of(\"Java 21 has arrived!!\"));\n        }\n    }\n}\n</code></pre>"},{"location":"extra-labs/graph-after-intermediate/","title":"Neo4J Lab - After Intermediate","text":"<p>This lab won't show the steps in much detail, instead, it will be shorter and you need to figure out (with some tips) how to implement it.</p> <p>Try to, first implement, and later, see the solution!</p>"},{"location":"extra-labs/graph-after-intermediate/#1-define-the-person-entity-class","title":"1. Define the <code>Person</code> Entity Class","text":"<ol> <li>Create a <code>record</code> called <code>Animal</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Define the record with the <code>@Entity</code> annotation from the <code>jakarta.nosql</code> package</li> <li> <p>Add two fields to the record:</p> <ul> <li><code>@Id Long id</code></li> <li><code>@Column String name</code></li> </ul> </li> <li> <p>Create static factory method <code>of</code> to provide a new instance of <code>Animal</code></p> </li> </ol>"},{"location":"extra-labs/graph-after-intermediate/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\n@Entity\npublic record Animal(@Id Long id, @Column String name) {\n\n    public static Animal of(String name){\n        return new Animal(null, name);\n    }\n}\n</code></pre>"},{"location":"extra-labs/graph-after-intermediate/#2-create-the-service-class","title":"2. Create the service class","text":"<ol> <li>Create a class called <code>AnimalService</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add all the fields and methods from the code below to the class and implement the empty methods</p> <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport org.eclipse.jnosql.mapping.graph.EntityTree;\nimport org.eclipse.jnosql.mapping.graph.GraphTemplate;\n\nimport java.util.List;\n\n@ApplicationScoped\npublic class AnimalService {\n\n    @Inject\n    private GraphTemplate template;\n\n    Animal animal(String name) {\n        // Create or retrieve a new Animal\n    }\n\n    public void eats(Animal animal, Animal animal2) {\n        // Create a relation \"eats\" between the animals who are in the food chain\n    }\n\n    List&lt;Animal&gt; eatsTwice() {\n        // Retrieve a list of animals that eats twice\n    }\n\n    List&lt;Animal&gt; untilGrass() {\n        // Retrieves the animals that eat until they reach an animal named \"grass\"\n    }\n\n    public EntityTree entityTree() {\n        // Return a `EntityTree` representing the tree structure of animals\n    }\n}\n</code></pre> </li> </ol>"},{"location":"extra-labs/graph-after-intermediate/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport org.eclipse.jnosql.mapping.graph.EntityTree;\nimport org.eclipse.jnosql.mapping.graph.GraphTemplate;\n\nimport java.util.List;\n\n@ApplicationScoped\npublic class AnimalService {\n\n    @Inject\n    private GraphTemplate template;\n\n    Animal animal(String name) {\n        return template.traversalVertex().hasLabel(Animal.class)\n            .has(\"name\", name)\n            .&lt;Animal&gt;next()\n            .orElseGet(() -&gt; template.insert(Animal.of(name)));\n    }\n\n    public void eats(Animal animal, Animal animal2){\n        this.template.edge(animal, \"eats\", animal2);\n    }\n\n    List&lt;Animal&gt; eatsTwice() {\n        return template.traversalVertex().hasLabel(Animal.class)\n            .repeat().in(\"eats\").times(2).&lt;Animal&gt;result().toList();\n    }\n\n    List&lt;Animal&gt; untilGrass() {\n        return template.traversalVertex().hasLabel(Animal.class)\n            .repeat().out(\"eats\").until().has(\"name\", \"grass\").&lt;Animal&gt;result()\n            .distinct().toList();\n    }\n\n    public EntityTree entityTree() {\n        return template.traversalVertex().hasLabel(Animal.class)\n            .repeat().in(\"eats\").times(4).tree();\n    }\n}\n</code></pre>"},{"location":"extra-labs/graph-after-intermediate/#3-create-the-execution-class","title":"3. Create the execution class","text":""},{"location":"extra-labs/graph-after-intermediate/#steps","title":"Steps","text":"<ol> <li>Create a class called <code>AppAnimal</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add the necessary below code to the class</p> <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.mapping.graph.EntityTree;\n\nimport java.util.List;\n\npublic class AppAnimal {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n\n            AnimalService service = container.select(AnimalService.class).get();\n\n            // Create and establish \"eats\" relationships between animals\n\n\n            // Use the service method eats() to define which animal can eat another one based on the chain food\n\n\n            // Retrieve and printout the list of animals that eat twice\n\n\n            // Retrieve and printout the list of animals that eat grass\n\n\n            // Retrieve the entity tree and print it out\n\n        }\n    }\n}\n</code></pre> </li> <li> <p>Take some time to understand what each method must do by reading the comments and implementing what's necessary in this class</p> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"extra-labs/graph-after-intermediate/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>The animals that eat twice: [Animal[id=18, name=frog], Animal[id=19, name=snake], Animal[id=20, name=eagle]]\n\nThe animals that eat until grass: [Animal[id=16, name=grass]]\n\nAt the top of the entity tree: [Animal[id=20, name=eagle]]\n</code></pre> </li> </ul>"},{"location":"extra-labs/graph-after-intermediate/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.mapping.graph.EntityTree;\n\nimport java.util.List;\n\npublic class AppAnimal {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n\n            AnimalService service = container.select(AnimalService.class).get();\n\n            // Create and establish \"eats\" relationships between animals\n            Animal grass = service.animal(\"grass\");\n            Animal grasshopper = service.animal(\"grasshopper\");\n            Animal frog = service.animal(\"frog\");\n            Animal snake = service.animal(\"snake\");\n            Animal eagle = service.animal(\"eagle\");\n\n            // Use the service method eats() to define which animal can eat another one based on the chain food\n            service.eats(eagle, snake);\n            service.eats(snake, frog);\n            service.eats(frog, grasshopper);\n            service.eats(grasshopper, grass);\n\n            // Retrieve and printout the list of animals that eat twice\n            List&lt;Animal&gt; animalEatsTwice = service.eatsTwice();\n            System.out.println(\"The animals that eat twice: \" + animalEatsTwice);\n\n            // Retrieve and printout the list of animals that eat grass\n            List&lt;Animal&gt; animalEatGrass = service.untilGrass();\n            System.out.println(\"The animals that eat until grass: \" + animalEatGrass);\n\n            // Retrieve the entity tree and print it out\n            EntityTree entityTree = service.entityTree();\n            System.out.println(\"At the top of the entity tree: \" + entityTree.getLeaf().toList());\n        }\n    }\n}\n</code></pre>"},{"location":"extra-labs/graph-intermediate/","title":"Neo4J Lab - Intermediate","text":"<p>This lab won't show the steps in much detail, instead, it will be shorter and you need to figure out (with some tips) how to implement it.</p> <p>Try to, first implement, and later, see the solution!</p>"},{"location":"extra-labs/graph-intermediate/#1-define-the-person-entity-class","title":"1. Define the <code>Person</code> Entity Class","text":"<ol> <li>Create a class called <code>Person</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Define the class with the <code>@Entity</code> annotation from the <code>jakarta.nosql</code> package</li> <li> <p>Add the following <code>private</code> fields:</p> Annotation Type Name <code>@Id</code> <code>Long</code> <code>id</code> <code>@Column</code> <code>String</code> <code>name</code> <code>@column</code> <code>long</code> <code>age</code> <code>@Column</code> <code>String</code> <code>occupation</code> <code>@Column</code> <code>Double</code> <code>salary</code> </li> <li> <p>Implement constructors, getter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods</p> </li> </ol>"},{"location":"extra-labs/graph-intermediate/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\n@Entity\npublic class Person {\n\n    @Id\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Column\n    private Long age;\n\n    @Column\n    private String occupation;\n\n    @Column\n    private Double salary;\n\n    public Person() {\n    }\n\n    public Person(String name, Long age, String occupation, Double salary) {\n        this.name = name;\n        this.age = age;\n        this.occupation = occupation;\n        this.salary = salary;\n    }\n\n    // other methods ignored\n}\n</code></pre>"},{"location":"extra-labs/graph-intermediate/#2-implement-the-builder-class","title":"2. Implement the Builder class","text":""},{"location":"extra-labs/graph-intermediate/#steps","title":"Steps","text":"<ol> <li>Create a class called <code>PersonBuilder</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Add the same fields we had previously added to the <code>Person</code> class, without the annotations</li> <li>Add the builder methods for each field</li> <li>Add the <code>build()</code> method creating a new instance of <code>Person</code> using its constructor</li> <li>In the <code>Person</code> class add the builder method referring to the <code>PersonBuilder</code></li> </ol>"},{"location":"extra-labs/graph-intermediate/#solution_1","title":"Solution","text":"Click to see... <pre><code>public class PersonBuilder {\n    private Long id;\n    private String name;\n    private Long age;\n    private String occupation;\n    private Double salary;\n\n    public PersonBuilder id(Long id) {\n        this.id = id;\n        return this;\n    }\n\n    public PersonBuilder name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public PersonBuilder age(Long age) {\n        this.age = age;\n        return this;\n    }\n\n    public PersonBuilder occupation(String occupation) {\n        this.occupation = occupation;\n        return this;\n    }\n\n    public PersonBuilder salary(Double salary) {\n        this.salary = salary;\n        return this;\n    }\n\n    public Person build() {\n        return new Person(name, age, occupation, salary);\n    }\n}\n</code></pre>"},{"location":"extra-labs/graph-intermediate/#3-create-the-service-class","title":"3. Create the service class","text":"<ol> <li>Create a class called <code>PersonService</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add all the fields and methods from the code below to the class</p> <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport org.eclipse.jnosql.mapping.graph.GraphTemplate;\nimport static org.apache.tinkerpop.gremlin.process.traversal.P.between;\nimport static org.apache.tinkerpop.gremlin.process.traversal.P.gte;\n\n@ApplicationScoped\npublic class PersonService {\n\n    @Inject\n    private GraphTemplate graph;\n\n    public Person save(Person person) {\n        // Save a person entity to the graph database\n    }\n\n    void knows(Person person, Person friend) {\n        // Establish a \"knows\" relationship between two persons\n    }\n\n    void love(Person person, Person friend) {\n        // Establish a \"knows\" relationship with a \"feel\" attribute set to \"love\"\n    }\n\n    List&lt;Person&gt; developers() {\n        // Retrieve a list of persons with the occupation \"Developer\" and salary &gt;= 3000 and age between 20 and 25\n    }\n\n    List&lt;Person&gt; whoDevelopersKnows() {\n        // Retrieve a list of persons known by developers with salary &gt;= 3000 and age between 20 and 25\n    }\n\n    List&lt;Person&gt; both() {\n        // Retrieve a list of persons who are developers and known by developers with salary &gt;= 3000 and age between 20 and 25\n    }\n\n    List&lt;Person&gt; couple() {\n        // Retrieve a list of developers who are in love (have a \"feel\" attribute set to \"love\")\n    }\n}\n</code></pre> </li> <li> <p>Take some time to understand what each method must do by reading the comments in the code or looking at the following table</p> Method Implementation <code>save</code> Save or retrieve a person that has a <code>name</code> using the <code>traversalVertex()</code> method from <code>graph</code> <code>knows</code> Create a relationship between two people using the label <code>\"knows\"</code> <code>love</code> Create a relationship between two people using the label <code>\"knows\"</code> adding two more relationships: <code>\"feels\"</code> and <code>\"love\"</code> <code>developers</code> Retrieve a list of people who have the occupation as <code>\"developer\"</code> and is a <code>\"Developer\"</code> <code>whoDevelopersKnows</code> Retrieve a list of people by developers with salary &gt;= 3000 and age between 20 and 25 <code>both</code> Retrieve a list of people who are developers and known by developers with salary &gt;= 3000 and age between 20 and 25 <code>couple</code> Retrieve a list of developers who are in love (have a \"feel\" attribute set to \"love\") </li> </ol>"},{"location":"extra-labs/graph-intermediate/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport org.eclipse.jnosql.mapping.graph.GraphTemplate;\n\nimport java.util.List;\n\nimport static org.apache.tinkerpop.gremlin.process.traversal.P.between;\nimport static org.apache.tinkerpop.gremlin.process.traversal.P.gte;\n\n@ApplicationScoped\npublic class PersonService {\n\n    @Inject\n    private GraphTemplate graph;\n\n    public Person save(Person person) {\n        return graph.traversalVertex().hasLabel(Person.class)\n            .has(\"name\", person.getName()).&lt;Person&gt;next()\n            .orElseGet(() -&gt; graph.insert(person));\n    }\n\n    void knows(Person person, Person friend) {\n        this.graph.edge(person, \"knows\", friend);\n    }\n\n    void love(Person person, Person friend) {\n        this.graph.edge(person, \"knows\", friend).add(\"feel\", \"love\");\n    }\n\n    List&lt;Person&gt; developers() {\n        return graph.traversalVertex().has(\"occupation\", \"Developer\")\n            .&lt;Person&gt;result().toList();\n    }\n\n    List&lt;Person&gt; whoDevelopersKnows() {\n        return graph.traversalVertex().has(\"salary\", gte(3_000D))\n            .has(\"age\", between(20, 25)).has(\"occupation\", \"Developer\").out(\"knows\")\n            .&lt;Person&gt;result().toList();\n    }\n\n    List&lt;Person&gt; both() {\n        return graph.traversalVertex().has(\"salary\", gte(3_000D)).has(\"age\", between(20, 25))\n            .has(\"occupation\", \"Developer\").outE(\"knows\").bothV().&lt;Person&gt;result()\n            .distinct().toList();\n    }\n\n    List&lt;Person&gt; couple() {\n        return graph.traversalVertex().has(\"salary\", gte(3_000D)).has(\"age\", between(20, 25))\n            .has(\"occupation\", \"Developer\").outE(\"knows\").has(\"feel\", \"love\").bothV()\n            .&lt;Person&gt;result().distinct().toList();\n    }\n}\n</code></pre>"},{"location":"extra-labs/graph-intermediate/#4-create-the-execution-class","title":"4. Create the execution class","text":""},{"location":"extra-labs/graph-intermediate/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>AppMarketing</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add the necessary below code to the class</p> <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport java.util.List;\n\npublic final class AppMarketing {\n\n    private AppMarketing() {\n    }\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n\n            PersonService service = container.select(PersonService.class).get();\n\n            // Create and save persons using the builder\n            Person banner = service.save(Person.builder().age(30L).name(\"Banner\")\n                .occupation(\"Developer\").salary(3_000D).build());\n\n            // Create and save more persons here...\n\n            // Establish \"knows\" and \"love\" relationships between persons\n\n            // Use the methods provided by the PersonService to query the graph database\n            List&lt;Person&gt; developers = service.developers();\n            List&lt;Person&gt; peopleWhoDeveloperKnows = service.whoDevelopersKnows();\n            List&lt;Person&gt; both = service.both();\n            List&lt;Person&gt; couple = service.couple();\n\n            // Print the results\n            System.out.println(\"Developers: \" + developers);\n            System.out.println(\"People who Developers know: \" + peopleWhoDeveloperKnows);\n            System.out.println(\"Both Developers and Known Persons: \" + both);\n            System.out.println(\"Developers in Love: \" + couple);\n        }\n    }\n}\n</code></pre> </li> <li> <p>Take some time to understand what each method must do by reading the comments and implementing what's necessary in this class</p> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"extra-labs/graph-intermediate/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Developers has salary greater than 3000 and age between 20 and 25: [Person{id=12, name='Banner', age=30, occupation='Developer', salary=3000.0}, Person{id=13, name='Natalia', age=32, occupation='Developer', salary=5000.0}, Person{id=15, name='tony', age=22, occupation='Developer', salary=4500.0}]\n\nPerson who the Developers target know: [Person{id=14, name='Rose', age=40, occupation='Design', salary=1000.0}, Person{id=13, name='Natalia', age=32, occupation='Developer', salary=5000.0}]\n\nThe person and the developers target: [Person{id=15, name='tony', age=22, occupation='Developer', salary=4500.0}, Person{id=14, name='Rose', age=40, occupation='Design', salary=1000.0}, Person{id=15, name='tony', age=22, occupation='Developer', salary=4500.0}, Person{id=13, name='Natalia', age=32, occupation='Developer', salary=5000.0}]\n\nDevelopers to Valentine days: [Person{id=15, name='tony', age=22, occupation='Developer', salary=4500.0}, Person{id=14, name='Rose', age=40, occupation='Design', salary=1000.0}]\n</code></pre> </li> </ul>"},{"location":"extra-labs/graph-intermediate/#solution_3","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport java.util.List;\n\npublic final class AppMarketing {\n\n    private AppMarketing() {\n    }\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n\n            PersonService service = container.select(PersonService.class).get();\n\n            Person banner = service.save(Person.builder().age(30L).name(\"Banner\")\n                .occupation(\"Developer\").salary(3_000D).build());\n\n            Person natalia = service.save(Person.builder().age(32L).name(\"Natalia\")\n                .occupation(\"Developer\").salary(5_000D).build());\n\n            Person rose = service.save(Person.builder().age(40L).name(\"Rose\")\n                .occupation(\"Design\").salary(1_000D).build());\n\n            Person tony =service.save(Person.builder().age(22L).name(\"tony\")\n                .occupation(\"Developer\").salary(4_500D).build());\n\n            service.love(tony, rose);\n            service.knows(tony, natalia);\n            service.knows(natalia, rose);\n            service.knows(banner, rose);\n\n            List&lt;Person&gt; developers = service.developers();\n\n            List&lt;Person&gt; peopleWhoDeveloperKnows =service.whoDevelopersKnows();\n\n            List&lt;Person&gt; both = service.both();\n\n            List&lt;Person&gt; couple = service.couple();\n\n            System.out.println(\"Developers has salary greater than 3000 and age between 20 and 25: \" + developers);\n            System.out.println(\"Person who the Developers target know: \" + peopleWhoDeveloperKnows);\n            System.out.println(\"The person and the developers target: \" + both);\n            System.out.println(\"Developers to Valentine days: \" + couple);\n        }\n    }\n}\n</code></pre>"},{"location":"graph/commands/","title":"Cypher commands","text":"Cypher Command Description <code>MATCH (node:Label)-[:RELATIONSHIP]-&gt;(other) RETURN node, other;</code> Retrieves nodes and relationships based on specified criteria, filtering and returning results. <code>CREATE (node:Label {property: value});</code> Creates nodes with optional labels and properties. You can also create relationships between nodes in the same query. <code>MERGE (node:Label {property: value});</code> Combines node creation and matching, ensuring that a node with the specified properties and labels either exists or is created. <code>DELETE node;</code> Removes nodes and their relationships from the graph. You can also use this command to delete relationships. <code>SET node.property = value;</code> Sets or updates the value of a property on a node or relationship. <code>RETURN DISTINCT node.property;</code> Returns distinct values of a specified property from the query results. <code>ORDER BY node.property ASC/DESC;</code> Orders query results based on the specified property in ascending (ASC) or descending (DESC) order. <code>LIMIT n;</code> Limits the number of results returned by the query to the specified value (n). <code>WITH node AS alias;</code> Creates an alias for a node or a result set, allowing you to reference it in subsequent parts of the query. <code>OPTIONAL MATCH (node)-[:RELATIONSHIP]-&gt;(other) RETURN node, other;</code> Performs a match operation that doesn't require a match to exist, allowing you to retrieve optional relationships without affecting the main query."},{"location":"graph/database-lab/","title":"Neo4J - Lab 1","text":"<p>In this lab session, we will explore Neo4j by setting up a Docker Neo4j instance using the provided command. We will cover the following:</p> <ol> <li>Launching a Docker Neo4j Container</li> <li>Accessing the Neo4j Browser Interface</li> <li>Creating a Sample Graph Database</li> <li>Running Cypher Queries</li> </ol>"},{"location":"graph/database-lab/#1-lauch-a-docker-neo4j-container","title":"1. Lauch a Docker Neo4j Container","text":""},{"location":"graph/database-lab/#steps","title":"Steps","text":"<ol> <li>Start up Docker</li> <li>Open your Terminal</li> <li> <p>Execute the following command</p> <pre><code>docker run --publish=7474:7474 --publish=7687:7687 --env NEO4J_AUTH=neo4j/admin123 neo4j\n</code></pre> <p>Info</p> <p>This command creates a Docker container running the Neo4j image, maps ports 7474 and 7687 from the container to the host machine, and sets the initial authentication to \"neo4j/admin123.\"</p> </li> </ol>"},{"location":"graph/database-lab/#2-access-the-neo4j-browser-interface","title":"2. Access the Neo4j Browser Interface","text":""},{"location":"graph/database-lab/#steps_1","title":"Steps","text":"<ol> <li>Open your web browser and navigate to http://localhost:7474</li> <li>Connect to the Neo4J using the following information:<ul> <li>Connect URL: <code>neo4j://neo4j://localhost:7687</code></li> <li>Database - leave empty for default: leave it empty</li> <li>Authentication type: <code>Username / Password</code></li> <li>Username: <code>neo4j</code></li> <li>Password: <code>admin123</code></li> </ul> </li> </ol>"},{"location":"graph/database-lab/#2-create-a-sample-graph-database","title":"2. Create a Sample Graph Database","text":""},{"location":"graph/database-lab/#steps_2","title":"Steps","text":"<ol> <li> <p>Create a simple graph database with nodes and relationships in the user interface</p> <ul> <li>paste the content into the top section on your screen with start with <code>neo4j$</code></li> <li> <p>hit the play button</p> <pre><code>CREATE (Alice:Person {name: \"Alice\", age: 30})\nCREATE (Bob:Person {name: \"Bob\", age: 25})\nCREATE (Charlie:Person {name: \"Charlie\", age: 35})\nCREATE (Alice)-[:FRIEND]-&gt;(Bob)\nCREATE (Alice)-[:FRIEND]-&gt;(Charlie)\n</code></pre> </li> </ul> </li> <li> <p>The following information in the log</p> <pre><code>Added 3 labels, created 3 nodes, set 6 properties, created 2 relationships, completed after 31 ms.\n</code></pre> </li> </ol>"},{"location":"graph/database-lab/#expected-results","title":"Expected results","text":""},{"location":"graph/database-lab/#4-run-cypher-queries","title":"4. Run Cypher Queries","text":""},{"location":"graph/database-lab/#steps_3","title":"Steps","text":"<ol> <li> <p>Run the following Cypher query into the Neo4J interface</p> <pre><code>MATCH (Alice:Person {name: \"Alice\"})-[:FRIEND]-&gt;(friend)\nRETURN Alice, friend\n</code></pre> </li> <li> <p>Click on the Graph icon in the left page</p> </li> </ol> <p>This query retrieves Alice and her friends.</p>"},{"location":"graph/database-lab/#expected-results_1","title":"Expected results","text":"<ul> <li> <p>The following relationship between <code>Alice</code> and its friends</p> <pre><code>erDiagram\nCharlie ||--o{ Alice : friend\nBob ||--o{ Alice : friend</code></pre> </li> </ul>"},{"location":"graph/introduction/","title":"Introducion","text":"<p>Graph databases represent a groundbreaking paradigm in the NoSQL landscape, designed to manage and traverse complex relationships and interconnected data. Unlike traditional databases, which excel at storing structured data in tables, graph databases specialize in modeling and querying intricate entities' networks and connections. For several compelling reasons, this innovative approach has garnered significant importance in the NoSQL world.</p> <ol> <li> <p>Relationship-Centric Data: In many modern applications, data is inherently relational. Graph databases represent relationships between data entities, making them ideal for scenarios such as social networks, recommendation systems, and fraud detection, where understanding connections is crucial.</p> </li> <li> <p>Efficient Relationship Traversal: Graph databases employ efficient algorithms for traversing relationships, allowing for lightning-fast querying of complex interconnected data. It is precious for applications that require real-time recommendations or pathfinding.</p> </li> <li> <p>Schema Flexibility: Like other NoSQL databases, graph databases offer schema flexibility, enabling the addition of new node and edge types without complex schema migrations. This agility supports iterative development and rapid adaptation to changing requirements.</p> </li> <li> <p>Semantic Modeling: Graph databases enable semantic modeling, allowing developers to express domain-specific knowledge in the data model itself. This is beneficial for representing ontologies, taxonomies, and knowledge graphs.</p> </li> <li> <p>Pattern Recognition: Graph databases are adept at pattern recognition within data, facilitating advanced analytics, anomaly detection, and the discovery of hidden insights in interconnected datasets.</p> </li> <li> <p>Scaling Relationships: graph databases can efficiently scale to handle the increased complexity as relationships grow in applications. Sharding techniques ensure that the data remains manageable and query performance stays optimal.</p> </li> <li> <p>Cypher Query Language: Many graph databases, including Neo4j, offer the Cypher query language designed explicitly for querying graph data. Cypher's intuitive syntax simplifies relationship traversal and pattern matching.</p> </li> <li> <p>Real-Time Processing: Graph databases are well-suited for real-time applications where rapid data updates and queries are necessary, such as fraud detection and recommendation systems.</p> </li> <li> <p>Use Cases: Graph databases are employed in diverse use cases, including social networks, recommendation engines, fraud detection, knowledge graphs, network analysis, and logistics optimization. Their versatility allows them to shine in various industries and domains.</p> </li> <li> <p>Community and Ecosystem: Graph database communities and ecosystems are growing, with dedicated tools, libraries, and resources available for developers, making it easier to build and integrate graph database-powered applications.</p> </li> </ol> Use Case Description Social Network Analysis Ideal for modeling and analyzing social networks, representing users, connections, and interactions, enabling features like friend recommendations, content sharing, and social analytics Recommendation Engines Powers personalized recommendation systems by modelin g user preferences, products, and relationships, delivering tailored product recommendations, content suggestions, and advertisements. Fraud Detection Invaluable for fraud detection by modeling intricate networks of transactions, accounts, and suspicious patterns, making it easier to identify and prevent fraudulent activities. Knowledge Graphs Utilized knowledge graphs to represent semantic relationships between concepts, allowing advanced semantic search, question answering, and domain-specific knowledge representation in education, healthcare, and research. Network Infrastructure Benefits IT and network management systems by modeling complex network infrastructures, dependencies, configurations, and real-time monitoring, facilitating resource allocation and troubleshooting. Impact Analysis Employed in finance for impact analysis by modeling dependencies and relationships between financial instruments, events, and market factors, aiding in risk assessment and decision-making. Content Recommendation Enhances content recommendation systems by modeling relationships between users, content, and interactions, improving content discovery, engagement, and personalization in media, e-commerce, and content platforms. Genealogy and Family Trees Utilized in genealogy applications to construct family trees, representing individuals and their familial connections, simplifying genealogical research, and preserving family histories. Logistics and Supply Chain Benefits logistics and supply chain management by modeling supply chain networks, optimizing routes, managing inventory, and enhancing tracking and delivery processes through efficient traversal of interconnected data. Network Analysis Applied in network analysis across fields like communication, transportation, and urban planning to study and optimize network structures, analyze traffic patterns, and make informed decisions for network improvements."},{"location":"graph/java-lab/","title":"Neo4J - Lab 2","text":"<p>In this lab, we will explore more about Neo4J and Java.</p>"},{"location":"graph/java-lab/#1-define-the-book-entity-class","title":"1. Define the <code>Book</code> Entity Class","text":""},{"location":"graph/java-lab/#steps","title":"Steps","text":"<ol> <li>Open the <code>06-graph</code> project and navigate to the <code>src/main/java</code></li> <li>Create a class called <code>Book</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Define the class with the <code>@Entity</code> annotation from the <code>jakarta.nosql</code> package</li> <li> <p>Add the following <code>private</code> fields:</p> <ul> <li><code>@Id Long id</code></li> <li><code>@Column String name</code></li> </ul> </li> <li> <p>Add a static method to create a book by a given <code>name</code></p> <pre><code>public static Book of(String name) {\n    return new Book(name);\n}\n</code></pre> </li> <li> <p>Implement constructors, getter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods</p> </li> </ol>"},{"location":"graph/java-lab/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\n@Entity\npublic class Book {\n\n    @Id\n    private Long id;\n\n    @Column\n    private String name;\n\n    public Book() {\n    }\n\n    public Book(String name) {\n        this.name = name;\n    }\n\n    public static Book of(String name) {\n        return new Book(name);\n    }\n\n    // other methods\n}\n</code></pre>"},{"location":"graph/java-lab/#2-create-the-category-class","title":"2. Create the <code>Category</code> Class","text":""},{"location":"graph/java-lab/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>Category</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Define the class with the <code>@Entity</code> annotation from the <code>jakarta.nosql</code> package</li> <li> <p>Add the following <code>private</code> fields:</p> <ul> <li><code>@Id Long id</code></li> <li><code>@Column String name</code></li> </ul> </li> <li> <p>Add a static method to create a book by a given <code>name</code></p> <pre><code>public static Category of(String name) {\n    return new Category(name);\n}\n</code></pre> </li> <li> <p>Implement constructors, getter methods, <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods</p> </li> </ol>"},{"location":"graph/java-lab/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Column;\nimport jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\n\n@Entity\npublic class Category {\n\n    @Id\n    private Long id;\n\n    @Column\n    private String name;\n\n    public Category() {\n    }\n\n    public Category(String name) {\n        this.name = name;\n    }\n\n    public static Category of(String name) {\n        return new Category(name);\n    }\n\n    // other methods\n}\n</code></pre>"},{"location":"graph/java-lab/#3-create-the-librarylabels-enum","title":"3. Create the <code>LibraryLabels</code> Enum","text":""},{"location":"graph/java-lab/#steps_2","title":"Steps","text":"<ol> <li>Create an <code>enum</code> called <code>LibraryLabels</code> in the <code>expert.os.labs.persistence</code> package</li> <li>It implements the <code>Supplier&lt;String&gt;</code> interface to provide a custom label for the relationship between books and categories</li> <li>Add the constant <code>IS</code></li> <li>Associate a value to the constant with the same name <code>is</code></li> <li>Define a <code>private</code> attribute to get the constant value</li> <li>Define a constructor to set the value</li> <li>Override the <code>get()</code> method from the <code>Supplier</code> returning the value attribute</li> </ol>"},{"location":"graph/java-lab/#solution_2","title":"Solution","text":"Click to see... <pre><code>import java.util.function.Supplier;\n\npublic enum LibraryLabels implements Supplier&lt;String&gt; {\n\n    IS(\"is\");\n\n    private String value;\n\n    LibraryLabels(String value) {\n        this.value = value;\n    }\n\n    @Override\n    public String get() {\n        return value;\n    }\n}\n</code></pre>"},{"location":"graph/java-lab/#4-create-the-bookservice-class","title":"4. Create the <code>BookService</code> Class","text":""},{"location":"graph/java-lab/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>BookService</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate it using the <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li> <p>Create a private field with the <code>GraphTemplate</code> type from the <code>org.eclipse.jnosql.mapping.graph</code> package</p> <ul> <li>name is as <code>graph</code></li> <li>add the annotation <code>@Inject</code> from the <code>jakarta.inject</code> package</li> </ul> <pre><code>@Inject\nprivate GraphTemplate graph;\n</code></pre> </li> <li> <p>Create a method named <code>category</code> that receives a <code>name</code> as input, retrieving or inserting it in the graph</p> <pre><code>Category category(String name) {\nreturn graph.traversalVertex().hasLabel(Category.class)\n    .has(\"name\", name)\n    .&lt;Category&gt;next()\n    .orElseGet(() -&gt; graph.insert(Category.of(name)));\n}\n</code></pre> </li> <li> <p>Create a method named <code>book</code> that receives a <code>name</code> as input, retrieving or inserting it in the graph</p> <pre><code>Book book(String name) {\n    return graph.traversalVertex().hasLabel(Book.class)\n        .has(\"name\", name)\n        .&lt;Book&gt;next()\n        .orElseGet(() -&gt; graph.insert(Book.of(name)));\n}\n</code></pre> </li> <li> <p>Create a method named <code>category</code> to establish a relationship between <code>Book</code> and <code>Category</code>, so they will become the parameters</p> <ul> <li> <p>use the <code>graph.edge()</code> method to establish the <code>IS</code> relationship</p> <pre><code>public void category(Book book, Category category){\n    this.graph.edge(book, LibraryLabels.IS, category);\n}\n</code></pre> </li> </ul> </li> <li> <p>Create a method named <code>category</code> to establish a relationship between other categories, creating a sub-category</p> <ul> <li>use the <code>graph.edge()</code> method to establish the <code>IS</code> relationship</li> </ul> <pre><code>public void category(Category subCategory, Category category){\n    this.graph.edge(subCategory, LibraryLabels.IS, category);\n}\n</code></pre> </li> <li> <p>Create a method to retrieve a list of categories by their name related to \"Software\"</p> <pre><code>public List&lt;String&gt; softwareCategories(){\nreturn graph.traversalVertex().hasLabel(Category.class)\n    .has(\"name\", \"Software\")\n    .in(LibraryLabels.IS).hasLabel(\"Category\").&lt;Category&gt;result()\n    .map(Category::getName)\n    .collect(Collectors.toList());\n}\n</code></pre> </li> <li> <p>Create a method to retrieve a list of books by their name related to \"Software\"</p> <pre><code>public List&lt;String&gt; softwareBooks(){\nreturn graph.traversalVertex().hasLabel(Category.class)\n    .has(\"name\", \"Software\")\n    .in(LibraryLabels.IS).hasLabel(Book.class).&lt;Book&gt;result()\n    .map(Book::getName)\n    .collect(Collectors.toList());\n}\n</code></pre> </li> <li> <p>Create a method to retrieve a list of books by its name related to \"Software\" and  \"NoSQL\"</p> <pre><code>public List&lt;String&gt; softwareNoSQLBooks(){\n    return graph.traversalVertex().hasLabel(Category.class)\n        .has(\"name\", \"Software\")\n        .in(LibraryLabels.IS)\n        .has(\"name\", \"NoSQL\")\n        .in(LibraryLabels.IS).&lt;Book&gt;result()\n        .map(Book::getName)\n        .collect(Collectors.toList());\n}\n</code></pre> </li> </ol>"},{"location":"graph/java-lab/#5-create-the-execution-class","title":"5. Create the execution class","text":""},{"location":"graph/java-lab/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>AppBook</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain a <code>BookService</code> instance from <code>jakarta.nosql.document</code> package by selecting it: <code>container.select(BookService.class).get()</code></p> <pre><code>BookService service = container.select(BookService.class).get();\n</code></pre> </li> <li> <p>Create the following categories by using the <code>BookService</code> instance</p> <ul> <li>Software</li> <li>Romance</li> <li>Java</li> <li>NoSQL</li> <li> <p>Micro Service</p> <pre><code>Category software = service.category(\"Software\");\nCategory romance = service.category(\"Romance\");\nCategory java = service.category(\"Java\");\nCategory nosql =service.category(\"NoSQL\");\nCategory microService =service.category(\"MicroService\");\n</code></pre> </li> </ul> </li> <li> <p>Create the following books by using the <code>BookService</code> instance</p> <ul> <li>Effective Java</li> <li>NoSQL Distilled</li> <li>Migrating to Microservice Databases</li> <li> <p>The Shack</p> <pre><code>Book effectiveJava = service.book(\"Effective Java\");\nBook nosqlDistilled = service.book(\"NoSQL Distilled\");\nBook migratingMicroservice = service.book(\"Migrating to Microservice Databases\");\nBook shack = service.book(\"The Shack\");\n</code></pre> </li> </ul> </li> <li> <p>Associate the sub-categories within the categories</p> <ul> <li>Java and Software</li> <li>NoSQL and Software</li> <li> <p>Microservice and Software</p> <pre><code>service.category(java, software);\nservice.category(nosql, software);\nservice.category(microService, software);\n</code></pre> </li> </ul> </li> <li> <p>Associate the books with the categories</p> <ul> <li>Effective Java and Software</li> <li>NoSQL Distilled and Software</li> <li> <p>MicroServices and Software        </p> <pre><code>service.category(effectiveJava, software);\nservice.category(nosqlDistilled, software);\nservice.category(migratingMicroservice, software);\n</code></pre> </li> </ul> </li> <li> <p>Associate the sub-category with the books</p> <ul> <li>Effective Java and Java</li> <li>NoSQL Distilled and NoSQL</li> <li>Migrating to Microservices to MicroService</li> <li> <p>Shack to Romance</p> <pre><code>service.category(effectiveJava, java);\nservice.category(nosqlDistilled, nosql);\nservice.category(migratingMicroservice, microService);\n</code></pre> </li> </ul> </li> <li> <p>Filter the software books by category using the <code>softwareCategories()</code> method and printout the result</p> <pre><code>List&lt;String&gt; softwareCategories =service.softwareCategories();\nSystem.out.println(\"Software Categories = \" + softwareCategories);\n</code></pre> </li> <li> <p>Filter all the software books by using the <code>softwareBooks()</code> method and printout the result</p> <pre><code>List&lt;String&gt; softwareBooks = service.softwareBooks();\nSystem.out.println(\"Software Books = \" + softwareBooks);\n</code></pre> </li> <li> <p>Filter all the software and NoSQL books by using the <code>softwareNoSQLBooks()</code> method and printout the result</p> <pre><code>List&lt;String&gt; softwareNoSQLBooks = service.softwareNoSQLBooks();\nSystem.out.println(\"Software and NoSQL Books = \" + softwareNoSQLBooks);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppBook</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppBook() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"graph/java-lab/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Software Categories = [NoSQL, Java, MicroService]\nSoftware Books = [Effective Java, NoSQL Distilled, Migrating to Microservice Databases]\nSoftware and NoSQL Books = [NoSQL Distilled]\n</code></pre> </li> </ul>"},{"location":"graph/java-lab/#solution_3","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\nimport java.util.List;\n\npublic class AppBook {\n\n    public static void main(String[] args) {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            BookService service = container.select(BookService.class).get();\n\n            Category software = service.category(\"Software\");\n            Category romance = service.category(\"Romance\");\n            Category java = service.category(\"Java\");\n            Category nosql =service.category(\"NoSQL\");\n            Category microService =service.category(\"MicroService\");\n\n            Book effectiveJava = service.book(\"Effective Java\");\n            Book nosqlDistilled = service.book(\"NoSQL Distilled\");\n            Book migratingMicroservice = service.book(\"Migrating to Microservice Databases\");\n            Book shack = service.book(\"The Shack\");\n\n            service.category(java, software);\n            service.category(nosql, software);\n            service.category(microService, software);\n\n            service.category(effectiveJava, software);\n            service.category(nosqlDistilled, software);\n            service.category(migratingMicroservice, software);\n\n            service.category(effectiveJava, java);\n            service.category(nosqlDistilled, nosql);\n            service.category(migratingMicroservice, microService);\n            service.category(shack, romance);\n\n            List&lt;String&gt; softwareCategories =service.softwareCategories();\n            System.out.println(\"Software Categories = \" + softwareCategories);\n\n            List&lt;String&gt; softwareBooks = service.softwareBooks();\n            System.out.println(\"Software Books = \" + softwareBooks);\n\n            List&lt;String&gt; softwareNoSQLBooks = service.softwareNoSQLBooks();\n            System.out.println(\"Software and NoSQL Books = \" + softwareNoSQLBooks);\n        }\n    }\n\n    private AppBook() {\n    }\n}\n</code></pre>"},{"location":"graph/neo4j/","title":"Neo4J Overview","text":"<p>Neo4j is a leading graph database management system renowned for its prowess in harnessing the power of graph data structures. As a pioneer in the graph database realm, Neo4j is designed to manage and query complex relationships within data seamlessly. It stores information as nodes and relationships, allowing organizations to intuitively model and traverse interconnected data, making it a standout choice for applications that rely on relationship-centric insights. Neo4j's innovative Cypher query language and powerful traversal capabilities enable agile development, real-time recommendations, social network analysis, and advanced data analytics, making it vital in unlocking valuable insights from highly interconnected datasets in today's data-driven world.</p> <ol> <li> <p>Native Graph Storage: Neo4j's core architecture is built around the property graph model, providing native storage and optimization for graph data. It ensures efficient traversal of complex relationships.</p> </li> <li> <p>Cypher Query Language: Neo4j introduces Cypher, a powerful and expressive query language designed explicitly for graph databases. Cypher makes it easy to query and manipulate graph data with a syntax that closely resembles patterns in the data.</p> </li> <li> <p>ACID Compliance: Neo4j offers ACID (Atomicity, Consistency, Isolation, Durability) compliance, ensuring data integrity and transactional consistency even in highly concurrent environments.</p> </li> <li> <p>Graph Algorithms: Neo4j includes a library of built-in graph algorithms, such as shortest path, community detection, and centrality measures, enabling complex analytical queries for various applications.</p> </li> <li> <p>Highly Scalable: Neo4j supports horizontal scalability through clustering and sharding, allowing organizations to handle massive graph datasets and high traffic loads.</p> </li> <li> <p>Native Indexing: Neo4j provides native indexing capabilities, including full-text search and spatial indexing, for efficient querying and data retrieval.</p> </li> <li> <p>Security: Neo4j offers robust security features, including role-based access control (RBAC), SSL encryption, and LDAP integration, ensuring data protection and access control.</p> </li> <li> <p>Rich Ecosystem: Neo4j has a vibrant ecosystem with various drivers, integrations, and extensions for popular programming languages and frameworks, simplifying application development and integration.</p> </li> <li> <p>Graph Algorithms Library: Neo4j's Graph Algorithms library includes a wide range of graph algorithms optimized for traversing and analyzing graph data efficiently.</p> </li> <li> <p>Real-Time Query Performance: Neo4j's query optimizer and caching mechanisms ensure fast real-time query performance, making it suitable for applications that require low-latency responses.</p> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-1/","title":"Jakarta CDI - Lab 1 - Basic part 1","text":"<p>In this lab, we will explore creating the first injection where the Vehicle interface into a single implementation Car.</p>"},{"location":"jakarta-ee/cdi-lab-1/#1-defining-the-interface","title":"1. Defining the interface","text":""},{"location":"jakarta-ee/cdi-lab-1/#steps","title":"Steps","text":"<ol> <li>Open the <code>01-jakarta-ee</code> project and navigate to the <code>src/main/java</code></li> <li>Create an interface called <code>Vehicle</code> in the <code>expert.os.labs.persistence.cid.vehicle</code> package</li> <li> <p>Add a method called <code>move()</code></p> <p>Info</p> <p>The <code>move()</code> method represents the action of moving a vehicle. Any class implementing this interface must provide an implementation for this method.</p> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-1/#expected-results","title":"Expected results","text":"<ul> <li>Interface <code>Vehicle</code> created in the <code>src/main/java</code> at the <code>expert.os.labs.persistence.cdi.vehicle</code></li> </ul>"},{"location":"jakarta-ee/cdi-lab-1/#solution","title":"Solution","text":"Click to see... <pre><code>public interface Vehicle {\n\n    void move();\n}\n</code></pre>"},{"location":"jakarta-ee/cdi-lab-1/#2-defining-the-class","title":"2. Defining the class","text":""},{"location":"jakarta-ee/cdi-lab-1/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>Car</code> in the <code>expert.os.labs.persistence.cid.vehicle</code> package</li> <li>Implements the <code>Vehicle</code> interface</li> <li> <p>Annotate the <code>Car</code> class with the <code>@ApplicationScoped</code> annotation from <code>jakarta.enterprise.context</code> package</p> <p>Info</p> <p>This annotation is commonly used in Jakarta EE (formerly Java EE) to define a class as an application-scoped bean. It means that only one instance of this class will be created and managed by the Jakarta EE container throughout the application's lifetime.</p> </li> <li> <p>Declare a logger for this class</p> <p>Tip</p> <p>You can use the <code>java.util.logging.Logger</code> class <pre><code>private static final Logger LOGGER = Logger.getLogger(Car.class.getName());\n</code></pre></p> </li> <li> <p>Add a field called <code>name</code> of type <code>String</code></p> </li> <li> <p>Add a constructor to the class associating a random Sxtring to the <code>name</code> field</p> <p>Tip</p> <p>You can use the <code>UUID.randomUUID().toString()</code> method to generate a random String</p> </li> <li> <p>Override the method <code>move()</code> by logging the <code>name</code> of the vehicle using the logger</p> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-1/#expected-results_1","title":"Expected results","text":"<ul> <li>Class <code>Car</code> implementing <code>Vehicle</code> created containing a method <code>move()</code></li> </ul>"},{"location":"jakarta-ee/cdi-lab-1/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\n\nimport java.util.Objects;\nimport java.util.UUID;\nimport java.util.logging.Logger;\n\n@ApplicationScoped\npublic class Car implements Vehicle {\n\n    private static final Logger LOGGER = Logger.getLogger(Car.class.getName());\n\n    private final String name;\n\n    public Car() {\n        this.name = UUID.randomUUID().toString();\n    }\n\n    @Override\n    public void move() {\n        LOGGER.info(\"My car is moving. The car's name is: \" + name);\n    }\n}\n</code></pre>"},{"location":"jakarta-ee/cdi-lab-1/#3-explore-the-class-usage","title":"3. Explore the class usage","text":""},{"location":"jakarta-ee/cdi-lab-1/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>AppVehicle</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li> <p>Add the following code to the class</p> <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\npublic class AppVehicle {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Vehicle vehicle = container.select(Vehicle.class).get();\n            vehicle.move();\n\n            Car car = container.select(Car.class).get();\n            car.move();\n        }\n    }\n}\n</code></pre> </li> <li> <p>Run the class</p> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-1/#expected-results_2","title":"Expected results","text":"<ul> <li> <p>Two logs related to the <code>move()</code> method execution, one for the <code>vehicle.move()</code> and another from the <code>car.move()</code> showing:</p> <pre><code>INFO: My car is moving. The car's name is: &lt;&lt;UUID&gt;&gt;\n</code></pre> </li> </ul>"},{"location":"jakarta-ee/cdi-lab-1/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\npublic class AppVehicle {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Vehicle vehicle = container.select(Vehicle.class).get();\n            vehicle.move();\n\n            Car car = container.select(Car.class).get();\n            car.move();\n        }\n    }\n}\n</code></pre>"},{"location":"jakarta-ee/cdi-lab-2/","title":"Jakarta CDI - Lab 1 - Basic part 2","text":"<p>In this lab, we will explore using CDI qualifiers to work when there are several implementations of a single interface.</p>"},{"location":"jakarta-ee/cdi-lab-2/#1-define-an-instrument","title":"1. Define an instrument","text":""},{"location":"jakarta-ee/cdi-lab-2/#steps","title":"Steps","text":"<ol> <li>Open the <code>01-jakarta-ee</code> project and navigate to the <code>src/main/java</code></li> <li>Create an <code>interface</code> called <code>Instrument</code> in the <code>expert.os.labs.persistence.cid.music</code> package</li> <li>Add a <code>sound()</code> method that returns <code>String</code></li> </ol>"},{"location":"jakarta-ee/cdi-lab-2/#expected-results","title":"Expected results","text":"<ul> <li>Interface <code>Instrument</code> that will produce a <code>sound()</code> for the later instrument types</li> </ul>"},{"location":"jakarta-ee/cdi-lab-2/#solution","title":"Solution","text":"Click to see... <pre><code>public interface Instrument {\n    String sound();\n}\n</code></pre>"},{"location":"jakarta-ee/cdi-lab-2/#2-define-the-instrument-types","title":"2. Define the instrument types","text":""},{"location":"jakarta-ee/cdi-lab-2/#steps_1","title":"Steps","text":"<ol> <li>Create an <code>enum</code> called <code>InstrumentType</code> in the <code>expert.os.labs.persistence.cid.music</code> package</li> <li>Add the following constants, related to the different musical instrument types:<ul> <li><code>STRING</code></li> <li><code>PERCUSSION</code></li> <li><code>KEYBOARD</code></li> </ul> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-2/#expected-results_1","title":"Expected results","text":"<ul> <li>Enum <code>InstrumentType</code> created in the <code>src/main/java</code> at the <code>expert.os.labs.persistence.cdi.music</code></li> </ul>"},{"location":"jakarta-ee/cdi-lab-2/#solution_1","title":"Solution","text":"Click to see... <pre><code>public enum InstrumentType {\n    STRING, PERCUSSION, KEYBOARD;\n}\n</code></pre>"},{"location":"jakarta-ee/cdi-lab-2/#3-create-a-custom-qualifier-annotation-the-musical-instruments","title":"3. Create a custom Qualifier Annotation (the musical instruments)","text":"<p>The annotated class will represent musical instruments and specify the instrument type.</p>"},{"location":"jakarta-ee/cdi-lab-2/#steps_2","title":"Steps","text":"<ol> <li>Create an <code>@interface</code> called <code>MusicalInstrument</code> in the <code>expert.os.labs.persistence.cid.music</code> package</li> <li> <p>Add the following code:</p> <pre><code>import jakarta.inject.Qualifier;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.*;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n@Qualifier\n@Retention(RUNTIME)\n@Target({TYPE, METHOD, FIELD, PARAMETER})\npublic @interface MusicalInstrument {\n    InstrumentType value();\n}\n</code></pre> </li> <li> <p>Define different musical instruments (classes), implementing the <code>Instrument</code> interface:</p> <ul> <li>the classes must be created at the <code>expert.os.labs.persistence.cid.music</code> package</li> <li>use the <code>jakarta.enterprise.inject</code> package to import the <code>@Default</code> annotation</li> </ul> Class Annotation sound <code>Piano</code> <code>@MusicalInstrument(InstrumentType.KEYBOARD)</code> and <code>@Default</code> <code>return \"piano\"</code> <code>Violin</code> <code>@MusicalInstrument(InstrumentType.STRING)</code> <code>return \"violin\"</code> <code>Xylophone</code> <code>@MusicalInstrument(InstrumentType.PERCUSSION)</code> <code>return \"xylophone\"</code> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-2/#expected-results_2","title":"Expected results","text":"<ul> <li>Three classes (<code>Piano</code>, <code>Violin</code>, and <code>Xylophone</code>) represent different musical instruments and are annotated with <code>MusicalInstrument</code> to specify their instrument types.</li> <li><code>@Default</code> annotation is used on the <code>Piano</code> class, indicating it as the default implementation for the <code>Instrument</code> interface.</li> </ul>"},{"location":"jakarta-ee/cdi-lab-2/#solution_2","title":"Solution","text":"Click to see... <p>Piano class <pre><code>import jakarta.enterprise.inject.Default;\n\n@MusicalInstrument(InstrumentType.KEYBOARD)\n@Default\nclass Piano implements Instrument {\n    @Override\n    public String sound() {\n        return \"piano\";\n    }\n}\n</code></pre></p> <p>Violin class <pre><code>@MusicalInstrument(InstrumentType.STRING)\nclass Violin implements Instrument {\n    @Override\n    public String sound() {\n        return \"violin\";\n    }\n}\n</code></pre></p> <p>Xylophone class <pre><code>@MusicalInstrument(InstrumentType.PERCUSSION)\nclass Xylophone implements Instrument {\n    @Override\n    public String sound() {\n        return \"xylophone\";\n    }\n}\n</code></pre></p>"},{"location":"jakarta-ee/cdi-lab-2/#4-create-the-orchestra","title":"4. Create the orchestra","text":"<p>The <code>Orchestra</code> class represents an orchestra and is annotated with <code>@ApplicationScoped</code>, indicating that there will be a single instance of this class per application.</p> <p>It contains fields for different types of musical instruments (<code>percussion</code>, <code>keyboard</code>, <code>string</code>, and <code>solo</code>) and an <code>Instance&lt;Instrument&gt;</code> to handle multiple instrument instances. The class includes methods to play specific types of instruments (<code>string()</code>, <code>percussion()</code>, <code>keyboard()</code>), play a solo instrument (<code>solo()</code>), and play all available instruments (<code>allSound()</code>).</p>"},{"location":"jakarta-ee/cdi-lab-2/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>Orchestra</code> in the <code>expert.os.labs.persistence.cid.music</code> package</li> <li>Annotate the class with <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li> <p>Add a logger for this class</p> <pre><code>private static final Logger LOGGER = Logger.getLogger(Orchestra.class.getName());\n</code></pre> </li> <li> <p>Add the following <code>Instrument</code> fields with the related annotations</p> Field name Annotation 1 Annotation 2 <code>percussion</code> <code>@Inject</code> <code>@MusicalInstrument(InstrumentType.PERCUSSION)</code> <code>keyboard</code> <code>@Inject</code> <code>@MusicalInstrument(InstrumentType.KEYBOARD)</code> <code>string</code> <code>@Inject</code> <code>@MusicalInstrument(InstrumentType.STRING)</code> <code>solo</code> <code>@Inject</code> </li> <li> <p>Add the <code>Instrument</code> instance as a new field as follows:</p> <pre><code>@Inject\n@Any\nprivate Instance&lt;Instrument&gt; instruments;\n</code></pre> </li> <li> <p>Add the following methods, that are related to each instrument type</p> <ul> <li> <p>you can use the following method template, replacing <code>${instrumentType}</code> with the list provided below:</p> <pre><code>public void ${instrumentType}() {\n    LOGGER.info(\"The ${instrumentType}'s sound: \" + this.${instrumentType}.sound());\n}\n</code></pre> Example <pre><code>public void percussion() {\n    LOGGER.info(\"The percussion's sound: \" + this.percussion.sound());\n}\n</code></pre> </li> <li> <p>methods to add:</p> method <code>percussion</code> <code>keyboard</code> <code>solo</code> </li> </ul> </li> <li> <p>Add a method to list all sounds</p> <pre><code>public void allSound() {\n    String sounds = this.instruments.stream().map(Instrument::sound).collect(Collectors.joining(\", \"));\n    LOGGER.info(\"All instruments sounds are: \" + sounds);\n}\n</code></pre> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-2/#expected-results_3","title":"Expected results","text":"<ul> <li>Class <code>Orchestra</code> that can call any musical instrument to play</li> </ul>"},{"location":"jakarta-ee/cdi-lab-2/#solution_3","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.enterprise.inject.Any;\nimport jakarta.enterprise.inject.Instance;\nimport jakarta.inject.Inject;\n\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n@ApplicationScoped\npublic class Orchestra {\n\n    private static final Logger LOGGER = Logger.getLogger(Orchestra.class.getName());\n\n    @Inject\n    @MusicalInstrument(InstrumentType.PERCUSSION)\n    private Instrument  &lt;;\n\n    @Inject\n    @MusicalInstrument(InstrumentType.KEYBOARD)\n    private Instrument keyboard;\n\n    @Inject\n    @MusicalInstrument(InstrumentType.STRING)\n    private Instrument string;\n\n    @Inject\n    private Instrument solo;\n\n    @Inject\n    @Any\n    private Instance&lt;Instrument&gt; instruments;\n\n        public void string() {\n            LOGGER.info(\"The string's sound: \" + this.string.sound());\n        }\n\n        public void percussion() {\n            LOGGER.info(\"The percussion's sound: \" + this.percussion.sound());\n        }\n\n        public void keyboard() {\n            LOGGER.info(\"The keyboard's sound: \" + this.keyboard.sound());\n        }\n\n        public void solo() {\n            LOGGER.info(\"The solo's sound: \" + this.keyboard.sound());\n        }\n\n        public void allSound() {\n            String sounds = this.instruments.stream().map(Instrument::sound).collect(Collectors.joining(\", \"));\n            LOGGER.info(\"All instruments sounds are: \" + sounds);\n        }\n    }\n</code></pre>"},{"location":"jakarta-ee/cdi-lab-2/#5-explore-the-class-usage","title":"5. Explore the class usage","text":""},{"location":"jakarta-ee/cdi-lab-2/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>AppOrchestra</code> in the <code>expert.os.labs.persistence.cid</code> package</li> <li> <p>Add the following code to the class</p> <pre><code>import expert.os.labs.persistence.persistence.cdi.music.Orchestra;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\npublic class App2 {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Orchestra orchestra = container.select(Orchestra.class).get();\n\n            orchestra.percussion();\n            orchestra.keyboard();\n            orchestra.string();\n            orchestra.solo();\n            orchestra.allSound();\n        }\n    }\n}\n</code></pre> </li> <li> <p>Run the class</p> </li> </ol>"},{"location":"jakarta-ee/cdi-lab-2/#expected-results_4","title":"Expected results","text":"<ul> <li> <p>List of <code>INFO</code> messages related to each instrument called by the Orchestra</p> <pre><code>INFO: The percussion's sound: xylophone\nINFO: The keyboard's sound: piano\nINFO: The string's sound: violin\nINFO: The solo's sound: piano\nINFO: All instruments sounds are: piano, violin, xylophone\n</code></pre> </li> </ul>"},{"location":"jakarta-ee/cdi-lab-2/#solution_4","title":"Solution","text":"Click to see... <pre><code>import expert.os.labs.persistence.persistence.cdi.music.Orchestra;\nimport jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\n\npublic class AppOrchestra {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            Orchestra orchestra = container.select(Orchestra.class).get();\n\n            orchestra.percussion();\n            orchestra.keyboard();\n            orchestra.string();\n            orchestra.solo();\n            orchestra.allSound();\n        }\n    }\n}\n</code></pre>"},{"location":"jakarta-ee/cdi/","title":"CDI","text":"<p>In our journey toward seamlessly integrating Java with NoSQL databases for modern applications, we come across an indispensable tool called CDI, or Contexts and Dependency Injection. CDI is more than just an acronym; it represents a paradigm shift in managing dependencies, promoting reusability, and elevating Object-Oriented Programming (OOP) to new heights in enterprise development.</p> <p>At its core, CDI is a specification within the Jakarta EE ecosystem that simplifies how we create, manage, and inject dependencies in our Java applications. It allows us to embrace the principles of Inversion of Control (IoC) and Dependency Injection (DI), pivotal in developing robust, modular, and maintainable code.</p> <p>You might wonder, \"Why is CDI so crucial when working with NoSQL databases in modern applications?\" Let's explore a few compelling reasons:</p> <p>1. Decoupling and Flexibility: CDI enables us to decouple components, making our applications more flexible and adaptable. This flexibility becomes paramount when integrating with NoSQL databases, which often involve handling diverse data models. CDI allows us to swap out database implementations or adapt to schema changes with minimal impact on the rest of our application.</p> <p>2. Scalability and Testability: Modern applications demand scalability and robust testing. CDI promotes using design patterns like Singleton, which are instrumental in managing resources efficiently and achieving scalability. Additionally, it simplifies the testing process by allowing us to easily replace real implementations with mock objects during unit testing, ensuring our code is reliable and maintainable.</p> <p>3. Enhanced Object-Oriented Programming: CDI takes the principles of OOP to another level. It encourages the use of well-defined interfaces, key to building modular and reusable components. By adhering to CDI practices, we can create cleaner, more understandable code that's easier to extend and maintain.</p> <p>4. Loose Coupling: CDI promotes loose Coupling between components. In the context of NoSQL integration, where database structures can evolve rapidly, this loose Coupling ensures that changes to the database schema don't ripple through the entire application. We can adapt our data access components independently, avoiding cascading changes and reducing the risk of bugs.</p>"},{"location":"jakarta-ee/cdi/#cdi-scope","title":"CDI Scope","text":"CDI Scope Description Dependent The shortest-lived scope, tied to the lifecycle of the bean that declares it. Dependent beans are created and destroyed each time they are injected or requested. Request Scoped to an HTTP request in a web application. The bean instance is created for the duration of an HTTP request and destroyed when the request is completed. Session Scoped to an HTTP session in a web application. The bean instance is created when the session is initiated and destroyed when the session ends. Application Scoped to the entire lifecycle of the application. The bean instance is created when the application starts and destroyed when the application is shut down. Conversation Scoped to a long-running conversation in a web application. It spans multiple HTTP requests and allows maintaining a conversational state. The bean instance is created at the beginning of a conversation and destroyed when the conversation ends. Singleton Scoped to a single, shared instance across the entire application. The same bean instance is reused for all clients, promoting a global state and sharing among components. <p>These CDI scopes provide a powerful mechanism for managing the lifecycle and visibility of beans in your application, allowing you to control how and when dependencies are created and maintained. The choice of scope depends on the specific requirements of your application and how you want to manage bean instances and their interactions.</p>"},{"location":"jakarta-ee/cdi/#the-main-cdi-contexts-and-dependency-injection-feature-with-brief-descriptions","title":"The main CDI (Contexts and Dependency Injection) feature with brief descriptions:","text":"CDI Feature Description Dependency Injection Automatic injection of dependencies into components, simplifying the management of resources like NoSQL database clients or DAOs. Scopes Definition of bean lifecycles, allowing you to manage the duration and visibility of beans, such as NoSQL database connections. Interceptors Creation of interceptors to apply cross-cutting concerns (e.g., logging, security) to methods, enhancing NoSQL database access logic. Alternatives Configuration of alternative bean implementations, facilitating the flexibility to switch between different NoSQL database providers or configurations. Producers Implementation of producer methods to dynamically create and manage instances of beans, including NoSQL database connections. Event CDI's event mechanism enables communication between loosely coupled components by allowing one component to fire events and others to observe and react to them. This can be used to trigger actions based on NoSQL database changes or updates."},{"location":"jakarta-ee/introduction/","title":"Introduction","text":"<p>In today's fast-paced digital landscape, data has become the lifeblood of businesses, powering applications and services that cater to the ever-evolving needs of users. In the realm of Java-based application development, the integration between Java and NoSQL databases has emerged as a critical component. To harness the full potential of this integration, the Jakarta EE platform plays a pivotal role.</p> <p>Jakarta EE, formerly known as Java EE (Enterprise Edition), is an open-source, community-driven platform for building enterprise-level Java applications. It provides a robust, scalable, and portable foundation for developing and deploying mission-critical applications. While Jakarta EE covers a wide spectrum of functionalities, its relevance to the world of NoSQL databases is particularly noteworthy. Here are some key reasons why Jakarta EE is essential in the Java-NoSQL integration landscape:</p> <ol> <li> <p>Standardization: Jakarta EE standardizes Java-based enterprise applications, ensuring seamless integration with various NoSQL databases.</p> </li> <li> <p>Extensibility: The platform allows developers to extend its capabilities to accommodate specific NoSQL database requirements, fostering innovation.</p> </li> <li> <p>Scalability: Jakarta EE complements the scalability of NoSQL databases, offering features for building scalable, distributed, and fault-tolerant applications.</p> </li> <li> <p>Flexibility: It supports various programming models, such as microservices and serverless architectures, adapting to different NoSQL database use cases.</p> </li> <li> <p>Community Support: Jakarta EE benefits from an active community committed to keeping it up-to-date with the latest NoSQL database technologies, making it a reliable choice for enterprises.</p> </li> </ol> <p>Eclipse MicroProfile is a complementary open-source project to Jakarta EE, designed for microservices development in Java. While Jakarta EE excels at building enterprise-level applications, MicroProfile offers lightweight APIs tailored for microservices, including features like RESTful services, fault tolerance, and health checks. The two technologies work together seamlessly, allowing developers to leverage Jakarta EE for robust enterprise components and MicroProfile for agile microservices development, resulting in a versatile and scalable Java-based solution.</p> <p>This initial segment of the workshop marks the foundational phase, and it's crucial for a specific reason \u2013 these components, namely JAX-RS, CDI, and validation, form the core building blocks of any integration we will explore further in this training. Understanding these technologies is akin to mastering the toolkit that empowers you to integrate Java applications with NoSQL databases seamlessly. As we progress through the workshop, you'll find that these fundamentals are essential for unlocking the full potential of Jakarta EE in NoSQL integration scenarios. They lay the groundwork upon which we will build more advanced and specialized skills, ultimately enabling you to create robust, data-driven solutions that can adapt to the ever-changing landscape of modern application development.</p>"},{"location":"jakarta-ee/jax-rs-lab/","title":"JAX-RS - Lab 1","text":"<p>In this lab, we will explore the JAX-RS capability of creating a fish API.</p>"},{"location":"jakarta-ee/jax-rs-lab/#1-defining-the-model-object","title":"1. Defining the model object","text":""},{"location":"jakarta-ee/jax-rs-lab/#steps","title":"Steps","text":"<ol> <li>Open the <code>02-jax-rs</code> project and navigate to the <code>src/main/java</code></li> <li>Create a <code>record</code> called <code>Fish</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Add the following parameters as <code>String</code>:<ul> <li><code>id</code></li> <li><code>name</code></li> <li><code>color</code></li> </ul> </li> </ol>"},{"location":"jakarta-ee/jax-rs-lab/#expected-results","title":"Expected results","text":"<ul> <li>Record <code>Fish</code> representing a simple Java record to model a fish created</li> </ul>"},{"location":"jakarta-ee/jax-rs-lab/#solution","title":"Solution","text":"Click to see... <pre><code>public record Fish(String id, String name, String color) {\n}\n</code></pre>"},{"location":"jakarta-ee/jax-rs-lab/#2-defining-the-database-class","title":"2. Defining the database class","text":""},{"location":"jakarta-ee/jax-rs-lab/#steps_1","title":"Steps","text":"<ol> <li>Create a <code>class</code> called <code>FishDatabase</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate the class with the <code>@ApplicationScoped</code> from the <code>jakarta.enterprise.context</code> package</li> <li> <p>Add a field to represent a collection of fishes</p> <pre><code>private Map&lt;String, Fish&gt; fishes;\n</code></pre> </li> <li> <p>Add a constructor to initialize the collection of fishes</p> <pre><code>public FishDatabase() {\n    this.fishes = new HashMap&lt;&gt;();\n}\n</code></pre> </li> <li> <p>Add the following methods with its specific return and body:</p> method method retun body <code>findAll()</code> <code>List&lt;Fish&gt;</code> <code>return List.copyOf(this.fishes.values());</code> <code>findById(String id)</code> <code>Optional&lt;Fish&gt;</code> <code>return Optional.ofNullable(this.fishes.get(id));</code> <code>save(Fish fish)</code> <code>void</code> <code>this.fishes.put(fish.id(), fish);</code> <code>delete(String id)</code> <code>void</code> <code>this.fishes.remove(id);</code> <code>clear()</code> <code>void</code> <code>this.fishes.clear();</code> </li> </ol>"},{"location":"jakarta-ee/jax-rs-lab/#expected-results_1","title":"Expected results","text":"<ul> <li>Database class with methods to support CRUD operations</li> </ul>"},{"location":"jakarta-ee/jax-rs-lab/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.context.ApplicationScoped;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\n@ApplicationScoped\npublic class FishDatabase {\n\n    private Map&lt;String, Fish&gt; fishes;\n\n    public FishDatabase() {\n        this.fishes = new HashMap&lt;&gt;();\n    }\n\n    public List&lt;Fish&gt; findAll() {\n        return List.copyOf(this.fishes.values());\n    }\n\n    public Optional&lt;Fish&gt; findById(String id) {\n        return Optional.ofNullable(this.fishes.get(id));\n    }\n\n    public void save(Fish fish) {\n        this.fishes.put(fish.id(), fish);\n    }\n\n    public void delete(String id) {\n        this.fishes.remove(id);\n    }\n\n    public void clear() {\n        this.fishes.clear();\n    }\n}\n</code></pre>"},{"location":"jakarta-ee/jax-rs-lab/#3-defining-the-resource-class","title":"3. Defining the resource class","text":""},{"location":"jakarta-ee/jax-rs-lab/#steps_2","title":"Steps","text":"<ol> <li>Create a <code>class</code> called <code>FishResource</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Annotate the class with the following</p> Annotations Package <code>@Path(\"/fishes\")</code> <code>jakarta.ws.rs</code> <code>@Consumes(MediaType.APPLICATION_JSON)</code> <code>jakarta.ws.rs</code> and <code>jakarta.ws.rs.core</code> <code>@Produces(MediaType.APPLICATION_JSON)</code> <code>jakarta.ws.rs</code> and <code>jakarta.ws.rs.core</code> </li> <li> <p>Inject the <code>FishDatabase</code> class by creating a field called <code>database</code></p> <pre><code>@Inject\nFishDatabase database;\n</code></pre> </li> <li> <p>Implement the <code>findAll()</code> method:</p> <ul> <li>use the <code>@GET</code> annotation</li> <li>the method returnss a <code>List&lt;Fish&gt;</code></li> <li> <p>the body should call the database-related method</p> <pre><code>@GET\npublic List&lt;Fish&gt; findAll() {\n   return this.database.findAll();\n}\n</code></pre> </li> </ul> </li> <li> <p>Implement the <code>findById()</code> method:</p> <ul> <li>use the <code>@GET</code> annotation together with the <code>@Path</code> to the <code>/{id}</code></li> <li>the method returns the <code>Fish</code> class</li> <li>the method has the <code>String id</code> parameter annotated with <code>@PathParam(\"id\")</code></li> <li> <p>the body should call the database-related method, if it's not found throw a <code>WebApplicationException</code> exception with HTTP 404</p> <pre><code>@GET\n@Path(\"/{id}\")\npublic Fish findById(@PathParam(\"id\") String id) {\n    return this.database.findById(id)\n    .orElseThrow(() -&gt; new WebApplicationException(\"Fish not found\", Response.Status.NOT_FOUND));\n}\n</code></pre> </li> </ul> </li> <li> <p>Implement the <code>save()</code> method</p> <ul> <li>use the <code>@POST</code> annotation</li> <li>the method is a <code>void</code></li> <li>the method has the <code>Fish fish</code> parameter</li> <li> <p>the body should call the database-related method</p> <pre><code>@POST\npublic void insert(Fish fish) {\n    this.database.save(fish);\n}\n</code></pre> <p>Note</p> <p>We know that an HTTP <code>POST</code> method should return the status code 201 and the location header for the resource created. In this exercise, it does not have a return to ease the persistence understanding.</p> </li> </ul> </li> <li> <p>Implement the <code>deleteById()</code> method</p> <ul> <li>use the <code>@DELETE</code> annotation together with the <code>@Path</code> to the <code>/{id}</code></li> <li>the method returns <code>void</code></li> <li>the method has the <code>String id</code> parameter annotated with <code>@PathParam(\"id\")</code></li> <li> <p>the body should call the database-related method</p> <pre><code>@DELETE\n@Path(\"/{id}\")\npublic void deleteById(@PathParam(\"id\") String id) {\n    this.database.delete(id);\n}\n</code></pre> </li> </ul> </li> </ol>"},{"location":"jakarta-ee/jax-rs-lab/#expected-results_2","title":"Expected results","text":"<ul> <li>A simple RESTful web service for managing fish records</li> </ul>"},{"location":"jakarta-ee/jax-rs-lab/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.inject.Inject;\nimport jakarta.ws.rs.*;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\n\nimport java.util.List;\n\n@Path(\"/fishes\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic class FishResource {\n\n    @Inject\n    FishDatabase database;\n\n    @GET\n    public List&lt;Fish&gt; findAll() {\n        return this.database.findAll();\n    }\n\n    @GET\n    @Path(\"/{id}\")\n    public Fish findById(@PathParam(\"id\") String id) {\n        return this.database.findById(id)\n        .orElseThrow(() -&gt; new WebApplicationException(\"Fish not found\", Response.Status.NOT_FOUND));\n    }\n\n    @POST\n    public void save(Fish fish) {\n        this.database.save(fish);\n    }\n\n    @DELETE\n    @Path(\"/{id}\")\n    public void deleteById(@PathParam(\"id\") String id) {\n        this.database.delete(id);\n    }\n}\n</code></pre>"},{"location":"jakarta-ee/jax-rs-lab/#4-testing-the-resources","title":"4. Testing the resources","text":""},{"location":"jakarta-ee/jax-rs-lab/#steps_3","title":"Steps","text":"<ol> <li>Open your Terminal</li> <li>Navigate to the <code>02-jax-rs</code> in the root project folder</li> <li> <p>Execute the following command to start the application</p> <pre><code>./mvnw quarkus:dev\n</code></pre> </li> <li> <p>Open a new Terminal window</p> </li> <li> <p>Run the following <code>curl</code> commands, looking at the related expected results:</p> Command Expected result <code>curl -X POST -H \"Content-Type: application/json\" -d '{\"id\":\"1\",\"name\":\"Nemo\",\"color\":\"Orange\"}' http://localhost:8080/fishes</code> nothing in the terminal <code>curl -X GET http://localhost:8080/fishes</code> <code>[{\"color\":\"Orange\",\"id\":\"1\",\"name\":\"Nemo\"}]</code> <code>curl -X GET http://localhost:8080/fishes/1</code> <code>[{\"color\":\"Orange\",\"id\":\"1\",\"name\":\"Nemo\"}]</code> <code>curl -X DELETE http://localhost:8080/fishes/1</code> nothing in the terminal </li> </ol>"},{"location":"jakarta-ee/jax-rs-lab/#expected-results_3","title":"Expected results","text":"<ul> <li>A simple RESTful web service for managing fish records where<ul> <li>the <code>FishDatabase</code> class manages the data</li> <li>the <code>FishResource</code> class exposes REST endpoints to interact with the data</li> </ul> </li> </ul>"},{"location":"jakarta-ee/jax-rs/","title":"JAX-RS","text":"<p>Java API for RESTful Web Services (JAX-RS) plays a pivotal role in the modern landscape of NoSQL databases. Its importance lies in providing a standardized and efficient way to build, expose, and consume RESTful APIs, aligning seamlessly with the principles and requirements of NoSQL databases. Here's why JAX-RS is indispensable in the NoSQL database ecosystem:</p>"},{"location":"jakarta-ee/jax-rs/#restful-communication","title":"RESTful Communication","text":"<p>NoSQL databases often rely on a RESTful architecture for data access and manipulation. JAX-RS provides a standardized and easy-to-understand way to design RESTful APIs, enabling applications to communicate with NoSQL databases over HTTP using well-defined endpoints.</p>"},{"location":"jakarta-ee/jax-rs/#simplified-integration","title":"Simplified Integration","text":"<p>JAX-RS simplifies the integration process between applications and NoSQL databases. Providing a uniform and language-agnostic approach to API development removes the complexities of underlying database technologies, making it easier to work with diverse NoSQL solutions.</p>"},{"location":"jakarta-ee/jax-rs/#scalability","title":"Scalability","text":"<p>NoSQL databases are known for their scalability, and JAX-RS aligns perfectly with this characteristic. It allows you to design scalable, stateless APIs that can handle a high volume of requests, making it suitable for applications with rapidly growing data needs.</p>"},{"location":"jakarta-ee/jax-rs/#flexibility","title":"Flexibility","text":"<p>NoSQL databases often cater to various data models (e.g., document, key-value, column-family), and JAX-RS accommodates this flexibility. You can design APIs that support diverse data structures, making them adaptable to the ever-changing schema requirements of NoSQL databases.</p>"},{"location":"jakarta-ee/jax-rs/#cross-platform-compatibility","title":"Cross-Platform Compatibility","text":"<p>JAX-RS is not limited to Java-only environments. It facilitates Communication between Java applications and NoSQL databases while remaining compatible with various programming languages and platforms, promoting interoperability.</p>"},{"location":"jakarta-ee/jax-rs/#security","title":"Security","text":"<p>Security is a paramount concern when interacting with NoSQL databases, and JAX-RS provides features for authentication, authorization, and secure Communication, ensuring that sensitive data in NoSQL databases is protected.</p>"},{"location":"jakarta-ee/jax-rs/#community-and-tooling","title":"Community and Tooling","text":"<p>JAX-RS benefits from a vibrant development community and many tools and libraries that simplify API development and testing. This ecosystem is invaluable when building applications that interact with NoSQL databases.</p>"},{"location":"jakarta-ee/jax-rs/#jax-rs-annotations","title":"JAX-RS annotations","text":"<p>These annotations are fundamental when building RESTful APIs using JAX-RS, enabling you to define resource endpoints, HTTP methods, parameter handling, media types, and more, ultimately creating robust and interoperable web services.</p> Annotation Description <code>@Path</code> Specifies the base URI path for a resource or resource method, allowing the mapping of HTTP requests to specific endpoints. <code>@GET</code> Indicates that a method handles HTTP GET requests, retrieving resource representations or data. <code>@POST</code> Marks a method to handle HTTP POST requests, typically used for creating or submitting data to the server. <code>@PUT</code> Designates a method to handle HTTP PUT requests, used for updating or replacing a resource's state. <code>@DELETE</code> Specifies that a method is responsible for handling HTTP DELETE requests, removing a resource from the server. <code>@PathParam</code> Retrieves values from URI path parameters and injects them into resource method parameters. <code>@QueryParam</code> Extracts values from query parameters in the URI and injects them into resource method parameters. <code>@FormParam</code> Reads data from HTML form submissions and injects it into resource method parameters. <code>@Produces</code> Specifies the media types (e.g., JSON, XML) that a resource method can produce as a response. <code>@Consumes</code> Indicates the media types that a resource method can accept as input data. <code>@HeaderParam</code> Extracts values from HTTP headers and injects them into resource method parameters. <code>@Context</code> Allows injection of context-specific objects (e.g., <code>UriInfo</code>, <code>HttpServletRequest</code>) into resource classes or methods. <code>@Provider</code> Marks a class as a JAX-RS provider, which can handle custom processing for request or response entities, exceptions, and other aspects of RESTful services."},{"location":"jakarta-ee/validation-lab-2/","title":"Jakarta Validation - Lab 2","text":"<p>The goal is to illustrate how to create a custom validation in Java using Jakarta Validation. We're developing a custom validation called <code>SalaryValidator</code> and an associated annotation named <code>SalaryConstraint</code>.</p> <p>This custom validation ensures that the <code>Money</code> field representing an employee's salary in the <code>Worker</code> class is non-null and greater than zero. This approach enhances data validation in Java applications, ensuring that salary values meet specific criteria and providing customized error messages for validation failures.</p>"},{"location":"jakarta-ee/validation-lab-2/#1-create-the-custom-constraint-class","title":"1. Create the custom constraint class","text":""},{"location":"jakarta-ee/validation-lab-2/#steps","title":"Steps","text":"<ol> <li>Open the <code>01-jakarta-ee</code> project and navigate to the <code>src/main/java</code></li> <li>Create an interface called <code>SalaryConstraint</code> in the <code>expert.os.labs.persistence.validation</code> package</li> <li> <p>Add the following annotations to the interface where:</p> <ul> <li>the <code>@Constraint</code> annotation come from the <code>jakarta.validation</code> package</li> <li>the other annotations come from the <code>java.lang.annotation</code> package</li> </ul> <pre><code>@Documented\n@Constraint(validatedBy = SalaryValidator.class)\n@Target( { ElementType.METHOD, ElementType.FIELD })\n@Retention(RetentionPolicy.RUNTIME)\n</code></pre> <p>Warning</p> <p>The <code>SalaryValidator.class</code> doesn't exist yet. We will create it in the next steps. For now, let your IDE complain about this missing class.</p> </li> <li> <p>Define the annotation attributes:</p> <ul> <li><code>message</code>, as the default message</li> <li><code>groups</code> as the class group</li> <li> <p><code>payload</code> as the <code>Payload</code> from the <code>jakarta.validation</code> package</p> <pre><code>String message() default \"Invalid salary\";\nClass&lt;?&gt;[] groups() default {};\nClass&lt;? extends Payload&gt;[] payload() default {};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"jakarta-ee/validation-lab-2/#expected-results","title":"Expected results","text":"<ul> <li>A new class <code>SalaryConstraint</code> that will be used for the custom validation</li> </ul>"},{"location":"jakarta-ee/validation-lab-2/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.validation.Constraint;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Documented\n@Constraint(validatedBy = SalaryValidator.class)\n@Target({ElementType.METHOD, ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SalaryConstraint {\n\n}\n</code></pre>"},{"location":"jakarta-ee/validation-lab-2/#2-create-the-custom-validator-class","title":"2. Create the custom validator class","text":""},{"location":"jakarta-ee/validation-lab-2/#steps_1","title":"Steps","text":"<ol> <li>Create a class <code>SalaryValidator</code> in the <code>expert.os.labs.persistence.validation</code> package</li> <li> <p>Make the class implements the <code>ConstraintValidator</code> interface, typing <code>SalaryConstraint</code> and the <code>Money</code> classes</p> <ul> <li>the <code>ConstraintValidator</code> class comes from the <code>jakarta.validation</code> package</li> <li>the <code>Money</code> class comes from the <code>org.joda.money</code> package</li> </ul> <pre><code>public class SalaryValidator implements ConstraintValidator&lt;SalaryConstraint, Money&gt; {\n}\n</code></pre> </li> <li> <p>Implements the <code>isValid</code> method (because, probably, your IDE will complain about it!)</p> <p>Tip</p> <p>Name the <code>Money</code> parameter as <code>salary</code> for clarity purposes</p> <pre><code>@Override\npublic boolean isValid(Money salary, ConstraintValidatorContext constraintValidatorContext) {\n   return false;\n}\n</code></pre> </li> <li> <p>Add the validation logic in the <code>isValid</code> method containing:</p> <ul> <li>check if the <code>salary</code> is not null</li> <li>check if the <code>salary</code> is not negative or zero</li> </ul> <p>Tips</p> <ul> <li>both checks can be connected to an <code>&amp;&amp;</code> operator</li> <li>you can use the method <code>isNegativeOrZero()</code> from the <code>value</code> field</li> </ul> </li> </ol>"},{"location":"jakarta-ee/validation-lab-2/#expected-results_1","title":"Expected results","text":"<ul> <li>A new class <code>SalaryValidator</code> that will be used to validate if the salary is not null and greater than zero</li> </ul>"},{"location":"jakarta-ee/validation-lab-2/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.validation.ConstraintValidator;\nimport jakarta.validation.ConstraintValidatorContext;\nimport org.joda.money.Money;\n\npublic class SalaryValidator implements ConstraintValidator&lt;SalaryConstraint, Money&gt; {\n   @Override\n   public boolean isValid(Money salary, ConstraintValidatorContext constraintValidatorContext) {\n      return salary != null &amp;&amp; salary.isNegativeOrZero();\n   }\n}\n</code></pre>"},{"location":"jakarta-ee/validation-lab-2/#3-add-the-salary-field-to-the-worker-class","title":"3. Add the salary field to the <code>Worker</code> class","text":""},{"location":"jakarta-ee/validation-lab-2/#steps_2","title":"Steps","text":"<ol> <li>Open the <code>Worker</code> class</li> <li>Add a new field called <code>salary</code> of type <code>Money</code> from the <code>org.joda.money</code> package</li> <li>Add the <code>@SalaryValidator</code> annotation to its field and associate the <code>message</code> attribute with the String <code>Salary should be greater than zero</code></li> <li>Add the field <code>salary</code> into the constructor</li> <li>Add the getter and setter for the <code>salary</code> field</li> <li>Add the field <code>salary</code> into the <code>toString()</code> method</li> </ol>"},{"location":"jakarta-ee/validation-lab-2/#expected-results_2","title":"Expected results","text":"<ul> <li>The class <code>Worker</code> with a new field <code>salary</code> with a custom constraint</li> </ul>"},{"location":"jakarta-ee/validation-lab-2/#solution_2","title":"Solution","text":"Click to see... <pre><code>public class Worker {\n   // previous fields ignored\n\n   @SalaryConstraint(message = \"Salary should be greater than zero\")\n   private Money salary;\n\n   public Worker(String nickname, String name, boolean working, String bio, int age, String email, Money salary) {\n      // previous attributes ignored\n      this.salary = salary;\n   }\n\n   public void setSalary(Money salary) {\n      this.salary = salary;\n   }\n\n   public void getSalary() {\n      return salary;\n   }\n}\n</code></pre>"},{"location":"jakarta-ee/validation-lab-2/#4-add-the-salary-field-to-the-workerbuilder-class","title":"4. Add the salary field to the <code>WorkerBuilder</code> class","text":""},{"location":"jakarta-ee/validation-lab-2/#steps_3","title":"Steps","text":"<ol> <li>Open the <code>WorkerBuilder</code> class</li> <li>Add a new field called <code>salary</code> of type <code>Money</code> from the <code>org.joda.money</code> package</li> <li>Add a new method for the <code>salary</code> field</li> <li>Include the <code>salary</code> field into the <code>build()</code> method</li> </ol>"},{"location":"jakarta-ee/validation-lab-2/#expected-results_3","title":"Expected results","text":"<ul> <li>The class <code>WorkerBuilder</code> with a new field <code>salary</code></li> </ul>"},{"location":"jakarta-ee/validation-lab-2/#solution_3","title":"Solution","text":"Click to see... <pre><code>public class WorkerBuilder {\n   // previous fields ignored\n\n   private Money salary;\n\n   // previous methods ignored\n\n   public WorkerBuilder salary(Money salary) {\n      this.salary = salary;\n      return this;\n   }\n\n   public Worker build() {\n      return new Worker(nickname, name, working, bio, age, email, salary);\n   }\n}\n</code></pre>"},{"location":"jakarta-ee/validation-lab-2/#5-create-a-test-for-the-salary-constraint","title":"5. Create a test for the salary constraint","text":""},{"location":"jakarta-ee/validation-lab-2/#steps_4","title":"Steps","text":"<ol> <li>Open the <code>WorkerTest</code> in the <code>src/test/java</code> at the <code>expert.os.labs.persistence.validation</code> package</li> <li>Add a new test called <code>shouldNotCreateWorkerWithNegativeSalary()</code></li> <li>Implement the test setting a negative value to the <code>salary()</code> method from the builder<ul> <li>the negative value can be set using <code>Money.of(CurrencyUnit.of(\"USD\"), -10)</code></li> <li>the assertion must validate if the message <code>Salary should be greater than zero</code> is present</li> </ul> </li> </ol>"},{"location":"jakarta-ee/validation-lab-2/#expected-results_4","title":"Expected results","text":"<ul> <li>A new test to validate the implementation of the custom validation for the <code>salary</code> field</li> </ul>"},{"location":"jakarta-ee/validation-lab-2/#solution_4","title":"Solution","text":"Click to see... <pre><code>@Test\nvoid shouldNotCreateWorkerWithNegativeSalary() {\n   Worker worker = Worker.builder()\n   .nickname(\"jonhdoe\")\n   .name(\"John Doe\")\n   .working(true)\n   .bio(\"I am a software engineer\")\n   .age(30)\n   .email(\"john.doe@gmail.com\")\n   .salary(Money.of(CurrencyUnit.of(\"USD\"), -10)).build();\n\n   Set&lt;ConstraintViolation&lt;Worker&gt;&gt; violations = validator.validate(worker);\n\n   Assertions.assertThat(violations).isNotEmpty().hasSize(1)\n      .map(ConstraintViolation::getMessage).contains(\"Salary should be greater than zero\");\n}\n</code></pre>"},{"location":"jakarta-ee/validation-lab/","title":"Jakarta Validation - Lab 1","text":"<p>In this lab we will create a model class with the Jakarta Validation annotations.</p>"},{"location":"jakarta-ee/validation-lab/#1-create-the-validation-class","title":"1. Create the validation class","text":""},{"location":"jakarta-ee/validation-lab/#steps","title":"Steps","text":"<ol> <li>Open the <code>01-jakarta-ee</code> project and navigate to the <code>src/main/java</code></li> <li>Create a class called <code>Worker</code> in the <code>expert.os.labs.persistence.validation</code> package</li> <li> <p>Add the following fields, adding the related annotations from the <code>jakarta.validation.constraints</code> package</p> <ul> <li> <p><code>nickname</code> field with <code>@NotBlank</code> annotation</p> <pre><code>@NotBlank(message = \"Nickname cannot be blank\")\nprivate String nickname;\n</code></pre> </li> <li> <p><code>name</code> field with <code>@NotBlank</code> annotation</p> <pre><code>@NotBlank(message = \"Name cannot be blank\")\nprivate String name;\n</code></pre> </li> <li> <p><code>working</code> field with <code>@AssertTrue</code> annotation</p> <pre><code>@AssertTrue\nprivate boolean working;\n</code></pre> </li> <li> <p><code>bio</code> field with <code>@Size</code> annotation:</p> <pre><code>@Size(min = 10, max = 200, message = \"Bio must be between 10 and 200 characters\")\nprivate String bio;\n</code></pre> </li> <li> <p><code>age</code> field with <code>@Min</code> and <code>@Max</code> annotations</p> <pre><code>@Min(value = 18, message = \"A worker should not be less than 18\")\n@Max(value = 80, message = \"A worker should not be greater than 80\")\nprivate int age;\n</code></pre> </li> <li> <p><code>email</code> field with <code>@Email</code> annotation:</p> <pre><code>@Email(message = \"Email should be valid\")\nprivate String email;\n</code></pre> </li> </ul> </li> </ol>"},{"location":"jakarta-ee/validation-lab/#expected-results","title":"Expected results","text":"<ul> <li>Class called <code>Worker</code> created in the <code>src/main/java</code> at the <code>expert.os.labs.persistence.validation</code> with all the Jakarta Validation annotations</li> </ul>"},{"location":"jakarta-ee/validation-lab/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.validation.constraints.AssertTrue;\nimport jakarta.validation.constraints.Email;\nimport jakarta.validation.constraints.Max;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.Size;\n\npublic class Worker {\n   @NotBlank(message = \"Nickname cannot be blank\")\n   private String nickname;\n\n   @NotBlank(message = \"Name cannot be blank\")\n   private String name;\n\n   @AssertTrue\n   private boolean working;\n\n   @Size(min = 10, max = 200, message = \"Bio must be between 10 and 200 characters\")\n   private String bio;\n\n   @Min(value = 18, message = \"A worker should not be less than 18\")\n   @Max(value = 80, message = \"A worker should not be greater than 80\")\n   private int age;\n\n   @Email(message = \"Email should be valid\")\n   private String email;\n}\n</code></pre>"},{"location":"jakarta-ee/validation-lab/#2-add-the-constructor-getters-setters-and-tostring","title":"2. Add the constructor, getters, setters, and toString","text":""},{"location":"jakarta-ee/validation-lab/#steps_1","title":"Steps","text":"<p>Tips</p> <p>You can use the shortcuts in your preffered IDE to generate the constructor, getters, setterns and <code>toString()</code></p> <ul> <li>IntelliJ IDEA: press <code>Command + N</code> and click in the related item</li> <li>Visual Studio Code: right-click in the code, click in the <code>Source Action</code> and then in the related item</li> </ul> <ol> <li>Add a constructor with all the fields present in the class</li> <li>Add the getters and setters for all the fields present in the class</li> <li>Add the <code>toString()</code> method with all the fields present in the class<ul> <li>don't forget to add the <code>@Override</code></li> </ul> </li> </ol>"},{"location":"jakarta-ee/validation-lab/#expected-results_1","title":"Expected results","text":"<ul> <li>The <code>Worker</code> class with the:<ul> <li>constructor</li> <li>getters and setters</li> <li><code>toString()</code></li> </ul> </li> </ul>"},{"location":"jakarta-ee/validation-lab/#solution_1","title":"Solution","text":"Click to see... <pre><code>    public class Worker {\n       @NotBlank(message = \"Nickname cannot be blank\")\n       private String nickname;\n\n       @NotBlank(message = \"Name cannot be blank\")\n       private String name;\n\n       @AssertTrue\n       private boolean working;\n\n       @Size(min = 10, max = 200, message = \"Bio must be between 10 and 200 characters\")\n       private String bio;\n\n       @Min(value = 18, message = \"A worker should not be less than 18\")\n       @Max(value = 80, message = \"A worker should not be greater than 80\")\n       private int age;\n\n       @Email(message = \"Email should be valid\")\n       private String email;\n\n       public Worker(String nickname, String name, boolean working, String bio, int age, String email) {\n          this.nickname = nickname;\n          this.name = name;\n          this.working = working;\n          this.bio = bio;\n          this.age = age;\n          this.email = email;\n       }\n\n       public String getNickname() {\n          return nickname;\n       }\n\n       public void setNickname(String nickname) {\n          this.nickname = nickname;\n       }\n\n       public String getName() {\n          return name;\n       }\n\n       public void setName(String name) {\n          this.name = name;\n       }\n\n       public boolean isWorking() {\n          return working;\n       }\n\n       public void setWorking(boolean working) {\n          this.working = working;\n       }\n\n       public String getBio() {\n          return bio;\n       }\n\n       public void setBio(String bio) {\n          this.bio = bio;\n       }\n\n       public int getAge() {\n          return age;\n       }\n\n       public void setAge(int age) {\n          this.age = age;\n       }\n\n       public String getEmail() {\n          return email;\n       }\n\n       public void setEmail(String email) {\n          this.email = email;\n       }\n\n       @Override\n       public String toString() {\n          return \"Worker{\" +\n          \"nickname='\" + nickname + '\\'' +\n          \", name='\" + name + '\\'' +\n          \", working=\" + working +\n          \", bio='\" + bio + '\\'' +\n          \", age=\" + age +\n          \", email='\" + email + '\\'' +\n          '}';\n       }\n    }\n</code></pre>"},{"location":"jakarta-ee/validation-lab/#3-create-a-builder-for-the-worker-class","title":"3. Create a builder for the <code>Worker</code> class","text":""},{"location":"jakarta-ee/validation-lab/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>WorkerBuilder</code> in the <code>src/main/java</code> folder at the <code>expert.os.labs.persistence.validation</code> package</li> <li>Add the same fields we had previously added to the <code>Worker</code> class, without the annotations     <pre><code>private String nickname;\nprivate String name;\nprivate boolean working;\nprivate String bio;\nprivate int age;\nprivate String email;\n</code></pre></li> <li> <p>Add the builder methods for each field</p> <ul> <li> <p>example using the <code>nickname</code> field</p> <pre><code>public WorkerBuilder nickname(String nickname) {\n   this.nickname = nickname;\n   return this;\n}\n</code></pre> </li> </ul> </li> <li> <p>Add the <code>build()</code> method creating a new instance of <code>Worker</code> using its constructor</p> </li> <li> <p>In the <code>Worker</code> class add the builder method referring to the <code>WorkerBuilder</code></p> <pre><code>public static WorkerBuilder build() {\n   return new WorkerBuilder();\n}\n</code></pre> </li> </ol>"},{"location":"jakarta-ee/validation-lab/#expected-results_2","title":"Expected results","text":"<ul> <li>A new <code>WorkerBuilder</code> class implementing the Builder pattern for the <code>Worker</code> class</li> <li>A new <code>builder()</code> method in the <code>Worker</code> class</li> </ul>"},{"location":"jakarta-ee/validation-lab/#solution_2","title":"Solution","text":"Click to see... <pre><code>public class WorkerBuilder {\n   private String nickname;\n   private String name;\n   private boolean working;\n   private String bio;\n   private int age;\n   private String email;\n\n   public WorkerBuilder nickname(String nickname) {\n      this.nickname = nickname;\n      return this;\n   }\n\n   public WorkerBuilder name(String name) {\n      this.name = name;\n      return this;\n   }\n\n   public WorkerBuilder working(boolean working) {\n      this.working = working;\n      return this;\n   }\n\n   public WorkerBuilder bio(String bio) {\n      this.bio = bio;\n      return this;\n   }\n\n   public WorkerBuilder age(int age) {\n      this.age = age;\n      return this;\n   }\n\n   public WorkerBuilder email(String email) {\n      this.email = email;\n      return this;\n   }\n\n   public Worker build() {\n      return new Worker(nickname, name, working, bio, age, email);\n   }\n}\n</code></pre>"},{"location":"jakarta-ee/validation-lab/#3-test-the-validations","title":"3. Test the validations","text":""},{"location":"jakarta-ee/validation-lab/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>WorkerTest</code> in the <code>src/test/java</code> folder at the <code>expert.os.labs.persistence.validation</code> package</li> <li> <p>Add a field called <code>validator</code> using the <code>Validator</code> class from the <code>jakarta.validation.Validator</code> package</p> <pre><code>private Validator validator;\n</code></pre> </li> <li> <p>Create a <code>setup</code> that will create a validator</p> <pre><code>@BeforeEach\npublic void setUp() {\n   ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n   validator = factory.getValidator();\n}\n</code></pre> </li> <li> <p>Create, at least, one of the following possible tests based on the validations we have added into the <code>Worker</code> class</p> field test <code>nickname</code> blank nickname <code>name</code> blank name <code>working</code> work set as false <code>bio</code> bio less than 10 or greater than 200 <code>age</code> age less than 18 or greater than 80 <code>email</code> invalid e-mail <ul> <li> <p>use the following code template as a test</p> <pre><code>@Test\nvoid shouldNotCreateWorkerWithBlankNickname() {\n   Worker worker = Worker.builder().nickname(\"\").name(\"John Doe\").working(true)\n       .bio(\"I am a software engineer\").age(38).email(\"john.doe@gmail.com\").build();\n   Set&lt;ConstraintViolation&lt;Worker&gt;&gt; violations = validator.validate(worker);\n\n   Assertions.assertThat(violations).isNotEmpty().hasSize(1)\n      .map(ConstraintViolation::getMessage).contains(\"Nickname cannot be blank\");\n   }\n</code></pre> </li> <li> <p>note that the <code>Assertions</code> class comes from the <code>org.assertj.core.api.Assertions.assertThat</code> and must be statically imported</p> </li> </ul> </li> <li> <p>Run the test</p> </li> </ol>"},{"location":"jakarta-ee/validation-lab/#expected-results_3","title":"Expected results","text":"<ul> <li>A new <code>WorkerTest</code> class created</li> <li>At least one test implemented</li> <li>Tests running without problems</li> </ul>"},{"location":"jakarta-ee/validation-lab/#solution_3","title":"Solution","text":"Click to see... <pre><code>class WorkerTest {\n\n   private Validator validator;\n\n   @BeforeEach\n   public void setUp() {\n      ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n      validator = factory.getValidator();\n   }\n\n   @Test\n   void shouldNotCreateWorkerWithBlankNickname1() {\n      Worker worker = Worker.builder().nickname(\"\").name(\"John\").working(true).bio(\"Bio of Elias\").age(38).email(\"elias@elias.com\").build();\n      Set&lt;ConstraintViolation&lt;Worker&gt;&gt; violations = validator.validate(worker);\n\n         assertThat(violations)\n         .isNotEmpty()\n         .hasSize(1)\n         .map(ConstraintViolation::getMessage).contains(\"Nickname cannot be blank\");\n      }\n   }\n</code></pre>"},{"location":"jakarta-ee/validation/","title":"Jakarta Validation","text":"<p>In this new training segment, we will dive into Jakarta Validation's importance in integrating Java with NoSQL databases, specifically Bean Validation. Jakarta Validation is pivotal in ensuring data consistency, mainly when dealing with schemaless databases.</p> <p>NoSQL databases, known for their flexibility, often need more rigid data schemas. While this flexibility is advantageous, it can also introduce challenges in maintaining data integrity. It is where Jakarta Validation comes to the rescue. </p> <p>Imagine a scenario where you must ensure that email addresses are valid and consistent across all records or that the format of dates like birthdays remains uniform. Jakarta Validation provides the tools and conventions to enforce these rules, guaranteeing data quality and integrity in your NoSQL database, even when dealing with unstructured or schemaless data.</p> <p>Jakarta Validation becomes an indispensable tool in your toolkit, allowing you to establish and enforce data validation rules consistently, ensuring that your Java applications interact seamlessly with NoSQL databases while maintaining data quality and reliability. As we delve deeper into this topic, you'll discover how Jakarta Validation can be effectively utilized to meet your specific data validation needs in NoSQL integration.</p> <p>Here's a table showcasing some of the main validation annotations available in Jakarta Validation (Bean Validation):</p> Annotation Description <code>@NotNull</code> Ensures that a field or parameter is not null. <code>@Size(min, max)</code> Validates the size of a string, collection, or array. <code>@Min(value)</code> Validates that a number is greater than or equal to the specified minimum. <code>@Max(value)</code> Validates that a number is less than or equal to the specified maximum. <code>@DecimalMin(value)</code> Validates that a decimal number is greater than or equal to the specified minimum value. <code>@DecimalMax(value)</code> Validates that a decimal number is less than or equal to the specified maximum value. <code>@Pattern(regex)</code> Validates that a string matches the specified regular expression pattern. <code>@Email</code> Validates that a string is a well-formed email address. <code>@Past</code> Ensures that a date or time is in the past. <code>@Future</code> Ensures that a date or time is in the future. <code>@AssertTrue</code> Validates that a boolean value is true. <code>@AssertFalse</code> Validates that a boolean value is false. <code>@NotBlank</code> Ensures that a string is not null and contains at least one non-whitespace character. <p>These annotations are commonly used to enforce validation rules for various data types in Java applications.</p>"},{"location":"key-value/database-lab/","title":"Redis - Lab 1","text":"<p>In this lab session, we will explore Redis by setting up a Docker Redis instance using the provided command. We will cover the following:</p> <ul> <li>Launching a Docker Redis Instance</li> <li>Connecting to the Redis Server</li> <li>Basic Redis Commands</li> </ul>"},{"location":"key-value/database-lab/#1-starting-redis","title":"1. Starting Redis","text":""},{"location":"key-value/database-lab/#steps","title":"Steps","text":"<ol> <li>Start up Docker</li> <li>Open your Terminal</li> <li> <p>Execute the following command</p> <pre><code>docker run --name redis-instance -p 6379:6379 -d redis\n</code></pre> <p>Info</p> <p>This command creates a Docker container named \"redis-instance\" running the Redis image, maps port 6379 on your host to port 6379 inside the container, and runs Redis in the background.</p> </li> </ol>"},{"location":"key-value/database-lab/#expected-results","title":"Expected results","text":"<ul> <li>The terminal will show the container ID</li> </ul>"},{"location":"key-value/database-lab/#2-connecting-to-the-redis-server","title":"2. Connecting to the Redis Server","text":"<p>Now, let's connect to the Redis server running in the Docker container. You can use the Redis CLI or a Redis client library in your preferred programming language. For this lab, we'll use the Redis CLI.</p>"},{"location":"key-value/database-lab/#steps_1","title":"Steps","text":"<ol> <li>Open the Terminal (or stay in the same Terminal window)</li> <li>Execute the following command</li> </ol> <pre><code>docker exec -it redis-instance redis-cli\n</code></pre>"},{"location":"key-value/database-lab/#expected-results_1","title":"Expected results","text":"<ul> <li>Connected to the Redis server where the command line will show <code>127.0.0.1:6379&gt;</code></li> </ul>"},{"location":"key-value/database-lab/#3-explore-the-basic-redis-commands","title":"3. Explore the basic Redis commands","text":""},{"location":"key-value/database-lab/#steps_2","title":"Steps","text":"<ol> <li>Execute the list of commands below, expecting its results</li> </ol> Description Command Result Set a key-value pair <code>SET mykey \"Hello, Redis!\"</code> OK Retrieve the value of a key <code>GET mykey</code> \"Hello, Redis!\" Increment a key's value <code>INCR mycounter</code> (integer) 1 Retrieve the incremented value <code>GET mycounter</code> \"1\" List all keys in the database <code>KEYS *</code> 1) \"mycounter\" 2) \"mykey\""},{"location":"key-value/introduction/","title":"Introducion","text":"<p>In the ever-evolving landscape of NoSQL databases, key-value databases stand out as a fundamental and versatile category. They offer a simple yet powerful data model that plays a crucial role in addressing modern applications' diverse data management needs.</p>"},{"location":"key-value/introduction/#simplicity-and-speed","title":"Simplicity and Speed","text":"<p>Key-value databases are designed for simplicity and speed. They excel in scenarios where rapid data retrieval based on a unique identifier (the \"key\") is paramount. This efficiency is crucial for applications requiring lightning-fast access to specific data points, such as caching, session management, and real-time analytics.</p>"},{"location":"key-value/introduction/#scalability","title":"Scalability","text":"<p>Key-value databases are inherently scalable. They distribute data across multiple nodes or clusters seamlessly, allowing applications to handle enormous data volumes and high concurrent read and write operations. This scalability is a cornerstone for web-scale applications and distributed systems.</p>"},{"location":"key-value/introduction/#flexibility","title":"Flexibility","text":"<p>The schema-less nature of key-value databases makes them incredibly flexible. They can store data, from simple strings and numbers to complex, nested objects. This flexibility aligns perfectly with the ever-changing requirements of modern applications, enabling developers to adapt to evolving data structures without schema constraints.</p>"},{"location":"key-value/introduction/#high-availability","title":"High Availability","text":"<p>Key-value databases prioritize high availability and fault tolerance. They employ replication and distributed architectures to ensure data remains accessible despite hardware failures or network issues. This resilience is essential for mission-critical applications that cannot afford downtime.</p>"},{"location":"key-value/introduction/#developer-friendly","title":"Developer-Friendly","text":"<p>These databases are developer-friendly due to their simplicity and ease of integration with programming languages like Java, Python, and Node.js. This ease of use accelerates application development and reduces time-to-market.</p> Use Case Description Caching and Performance Improve application performance by caching frequently used data, reducing load on primary databases. Session Management Efficiently manage user sessions and store user profiles, authentication tokens, and preferences. Distributed Systems Power real-time analytics, event-driven systems, and distributed architectures with rapid data access. Content Delivery and Caching Accelerate content delivery, reduce latency, and enhance user experiences through global caching. IoT Data Storage Efficiently handle high-volume IoT data, including sensor data, device information, and telemetry. Metadata and File Management Store file metadata for content management, enabling efficient search and categorization. Distributed Locking Ensure data consistency in distributed systems by supporting distributed locking mechanisms. Message Queues Enable inter-process communication and asynchronous processing using lightweight message queues. User Preferences Personalize user experiences by storing preferences and personalization data. Configuration Management Centrally manage configuration settings in distributed systems, facilitating dynamic updates. <p>These concise descriptions highlight the versatility and relevance of key-value databases in various application scenarios.</p>"},{"location":"key-value/java-lab-2/","title":"Redis - Lab 3","text":"<p>This lab will introduce an entity integration with Redis database with Java.</p>"},{"location":"key-value/java-lab-2/#1-create-an-entity","title":"1. Create an entity","text":""},{"location":"key-value/java-lab-2/#steps","title":"Steps","text":"<ol> <li>Create a class called <code>User</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate this class with <code>@Entity</code>, indicating that it's a persistent entity</li> <li> <p>Add the following <code>private</code> fields with its types</p> type field <code>String</code> <code>userName</code> <code>String</code> <code>name</code> <code>Map&lt;String, String&gt;</code> <code>settings</code> <code>Set&lt;String&gt;</code> <code>languages</code> </li> <li> <p>Annotate the <code>userName</code> with <code>@Id</code> from the <code>jakarta.nosql</code> package</p> </li> <li>Create a constructor using all fields</li> <li>Create get methods for each field</li> <li>Add the <code>toString()</code> method</li> </ol>"},{"location":"key-value/java-lab-2/#expected-results","title":"Expected results","text":"<ul> <li>Entity <code>User</code> created</li> </ul>"},{"location":"key-value/java-lab-2/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.nosql.Entity;\nimport jakarta.nosql.Id;\nimport java.util.Map;\nimport java.util.Set;\n\n\n@Entity\npublic class User {\n\n    @Id\n    private String userName;\n\n    private String name;\n\n    private Map&lt;String, String&gt; settings;\n\n    private Set&lt;String&gt; languages;\n\n    public User() {\n    }\n\n    public User(String userName, String name, Map&lt;String, String&gt; settings, Set&lt;String&gt; languages) {\n        this.userName = userName;\n        this.name = name;\n        this.settings = settings;\n        this.languages = languages;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Map&lt;String, String&gt; getSettings() {\n        return settings;\n    }\n\n    public Set&lt;String&gt; getLanguages() {\n        return languages;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n            \"userName='\" + userName + '\\'' +\n            \", name='\" + name + '\\'' +\n            \", settings=\" + settings +\n            \", languages=\" + languages +\n            '}';\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab-2/#2-implement-the-builder-class","title":"2. Implement the Builder class","text":""},{"location":"key-value/java-lab-2/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>UserBuilder</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Add the same fields we had previously added to the <code>User</code> class, without the annotations     <pre><code>private String userName;\nprivate String name;\nprivate Map&lt;String, String&gt; settings;\nprivate Set&lt;String&gt; languages;\n</code></pre></li> <li> <p>Add the builder methods for each field</p> <ul> <li> <p>example using the <code>userName</code> field</p> <pre><code>public UserBuilder userName(String userName) {\n   this.userName = userName;\n   return this;\n}\n</code></pre> </li> </ul> </li> <li> <p>Add the <code>build()</code> method creating a new instance of <code>User</code> using its constructor</p> </li> <li> <p>In the <code>User</code> class add the builder method referring to the <code>UserBuilder</code></p> <pre><code>public static UserBuilder builder() {\n   return new UserBuilder();\n}\n</code></pre> </li> </ol>"},{"location":"key-value/java-lab-2/#expected-results_1","title":"Expected results","text":"<ul> <li>A new <code>UserBuilder</code> class implementing the Builder pattern for the <code>User</code> class</li> <li>A new <code>builder()</code> method in the <code>User</code> class</li> </ul>"},{"location":"key-value/java-lab-2/#solution_1","title":"Solution","text":"Click to see... <pre><code>import java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class UserBuilder {\n\n    private String username;\n\n    private String name;\n\n    private Map&lt;String, String&gt; settings = Collections.emptyMap();\n\n    private Set&lt;String&gt; languages = Collections.emptySet();\n\n    public UserBuilder username(String username) {\n        this.username = username;\n        return this;\n    }\n\n    public UserBuilder name(String name) {\n        this.name = name;\n        return this;\n    }\n\n\n    public UserBuilder settings(Map&lt;String, String&gt; settings) {\n        this.settings = settings;\n        return this;\n    }\n\n    public UserBuilder languages(Set&lt;String&gt; languages) {\n        this.languages = languages;\n        return this;\n    }\n\n    public User build() {\n        return new User(username, name, settings, languages);\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab-2/#3-define-the-repository-interface","title":"3. Define the repository interface","text":"<ol> <li>Create an <code>interface</code> called <code>UserRepository</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate the class with <code>@Repository</code> from the <code>jakarta.data.repository</code> package</li> <li><code>extends</code> the class using <code>CrudRepository&lt;User, String&gt;</code> from the <code>jakarta.data.repository</code> package</li> </ol>"},{"location":"key-value/java-lab-2/#expected-results_2","title":"Expected results","text":"<ul> <li>The <code>UserRepository</code> that specifies methods for performing CRUD (Create, Read, Update, Delete) operations on <code>User</code> entities</li> </ul>"},{"location":"key-value/java-lab-2/#solution_2","title":"Solution","text":"Click to see... <pre><code>@Repository\npublic interface UserRepository extends CrudRepository&lt;User, String&gt; {\n}\n</code></pre>"},{"location":"key-value/java-lab-2/#4-create-the-execution-class","title":"4. Create the execution class","text":""},{"location":"key-value/java-lab-2/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>AppUser</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) throws InterruptedException {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain an instance of the <code>KeyValueTemplate</code> to interact with the key-value store</p> <pre><code>KeyValueTemplate template = container.select(KeyValueTemplate.class).get();\n</code></pre> </li> <li> <p>Create two user instances using the builder from the <code>User</code> class with different data inside the <code>try</code> statement</p> <pre><code>User user1 = User.builder().username(\"user1\").name(\"Otavio Santana\")\n    .languages(Set.of(\"Portuguese\", \"English\", \"Spanish\", \"Italian\", \"French\"))\n    .settings(Map.of(\"location\", \"Portugal\", \"currency\", \"EUR\")).build();\n\n\nUser user2 = User.builder().username(\"user2\").name(\"Poliana Santana\")\n    .languages(Set.of(\"Portuguese\", \"English\"))\n    .settings(Map.of(\"location\", \"Portugal\", \"currency\", \"EUR\")).build();\n</code></pre> </li> <li> <p>Add the two user instances into the key-value store using the <code>KeuValueTemplate</code>, where the second one will have a delay of 1 second</p> <pre><code>template.put(user1);\ntemplate.put(user2, Duration.ofSeconds(1));\n</code></pre> </li> <li> <p>Retrieve the <code>user2</code> data based on its <code>userName</code> and printout the result</p> <ul> <li>use the method <code>get()</code> from the <code>template</code> field</li> <li>the first parameter is the value of the <code>userName</code> field and the second parameter is the class</li> </ul> <pre><code>Optional&lt;User&gt; user2Data = template.get(\"user2\", User.class);\nSystem.out.println(\"User2 data: \" + user2Data);\n</code></pre> </li> <li> <p>Add a wait time, then retrieve and printout the same user again</p> <pre><code>TimeUnit.SECONDS.sleep(2L);\nOptional&lt;User&gt; user2DataSecondRetrieve = template.get(\"user2\", User.class);\nSystem.out.println(\"User2 second retrieve data: \" + user2DataSecondRetrieve);\n</code></pre> </li> <li> <p>Retrieve the <code>user1</code> data based on its <code>userName</code> and printout the result</p> <pre><code>Optional&lt;User&gt; user1Data = template.get(\"user1\", User.class);\nSystem.out.println(\"User1 data: \" + user1Data);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppUser</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppUser() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"key-value/java-lab-2/#expected-results_3","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>User2 data: Optional[User{userName='user2', name='Poliana Santana', settings={location=Portugal, currency=EUR}, languages=[English, Portuguese]}]\nUser2 second retrieve data: Optional.empty\nUser1 data: Optional[User{userName='user1', name='Otavio Santana', settings={location=Portugal, currency=EUR}, languages=[English, Italian, French, Portuguese, Spanish]}]\n</code></pre> </li> <li> <p>The second printout, related to the <code>user2</code> does not show any data because it expired</p> </li> </ul>"},{"location":"key-value/java-lab-2/#solution_3","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport jakarta.nosql.keyvalue.KeyValueTemplate;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\npublic class AppUser {\n\n    public static void main(String[] args) throws InterruptedException {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            KeyValueTemplate template = container.select(KeyValueTemplate.class).get();\n\n            User user1 = User.builder().username(\"user1\").name(\"Otavio Santana\")\n                .languages(Set.of(\"Portuguese\", \"English\", \"Spanish\", \"Italian\", \"French\"))\n                .settings(Map.of(\"location\", \"Portugal\", \"currency\", \"EUR\")).build();\n\n\n            User user2 = User.builder().username(\"user2\").name(\"Poliana Santana\")\n                .languages(Set.of(\"Portuguese\", \"English\"))\n                .settings(Map.of(\"location\", \"Portugal\", \"currency\", \"EUR\")).build();\n\n\n            template.put(user1);\n            template.put(user2, Duration.ofSeconds(1));\n\n            Optional&lt;User&gt; user2Data = template.get(\"user2\", User.class);\n            System.out.println(\"User2 data: \" + user2Data);\n\n            TimeUnit.SECONDS.sleep(2L);\n            Optional&lt;User&gt; user2DataSecondRetrieve = template.get(\"user2\", User.class);\n            System.out.println(\"User2 second retrieve data: \" + user2DataSecondRetrieve);\n\n            Optional&lt;User&gt; user1Data = template.get(\"user1\", User.class);\n            System.out.println(\"User1 data: \" + user1Data);\n        }\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab-2/#5-use-the-userrepository-with-redis","title":"5. Use the  <code>UserRepository</code> with Redis","text":""},{"location":"key-value/java-lab-2/#steps_3","title":"Steps","text":"<ol> <li>Create an interface called <code>UserRepository</code> in the <code>expert.os.labs.persistence</code> package</li> <li>Annotate the class with <code>@Repository</code> from the <code>jakarta.data.repository</code> package</li> <li> <p>Extends the interface using the <code>CrudRepository</code></p> <pre><code>extends CrudRepository&lt;User, String&gt;\n</code></pre> </li> </ol>"},{"location":"key-value/java-lab-2/#expected-results_4","title":"Expected results","text":"<ul> <li>The integration in Redis with the repository to perform the CRUD operations in the <code>User</code> entity</li> </ul>"},{"location":"key-value/java-lab-2/#solution_4","title":"Solution","text":"Click to see... <pre><code>import jakarta.data.repository.CrudRepository;\nimport jakarta.data.repository.Repository;\n\n@Repository\npublic interface UserRepository extends CrudRepository&lt;User, String&gt; {\n}\n</code></pre>"},{"location":"key-value/java-lab-2/#6-using-the-userrepository","title":"6. Using the <code>UserRepository</code>","text":""},{"location":"key-value/java-lab-2/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>AppRepository</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Add the <code>UserRepository</code> instance</p> <pre><code> UserRepository repository = container.select(UserRepository.class).get();\n</code></pre> </li> <li> <p>Create a new <code>User</code> object</p> <pre><code>User ada = User.builder().username(\"ada\").name(\"Ada Lovelace\")\n            .languages(Set.of(\"Latin\")).settings(Map.of(\"currency\", \"food\")).build();\n</code></pre> </li> <li> <p>Save the <code>User</code> object</p> <pre><code>repository.save(ada);\n</code></pre> </li> <li> <p>Retrieve the <code>User</code> object saved by its id, which is <code>username</code>, using the <code>findById</code> method from the repository and printout the result</p> <pre><code>Optional&lt;User&gt; userFound = repository.findById(\"ada\");\nSystem.out.println(userFound);\n</code></pre> </li> <li> <p>Check if a user already exists using the <code>existsById</code> method from the repository, and printout the result</p> <pre><code>boolea userExist = repository.existsById(\"ada\");\nSystem.out.println(\"userExist? = \" + userExist);\n</code></pre> </li> <li> <p>Delete the user using the <code>deleteById</code> method</p> <pre><code>repository.deleteById(\"ada\");\n</code></pre> </li> <li> <p>Check if a user still exists using the <code>existsById</code> method from the repository, and printout the result</p> <pre><code>userExist = repository.existsById(\"ada\");\nSystem.out.println(\"userExist? = \" + userExist);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>AppRepository</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppRepository() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"key-value/java-lab-2/#expected-results_5","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Optional[User{userName='ada', name='Ada Lovelace', settings={currency=food}, languages=[Latin]}]\nuserExist? = true\nuserExist? = false\n</code></pre> </li> </ul>"},{"location":"key-value/java-lab-2/#solution_5","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\npublic class AppRepository {\n\n    public static void main(String[] args) {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n\n            UserRepository repository = container.select(UserRepository.class).get();\n            User ada = User.builder().username(\"ada\").name(\"Ada Lovelace\")\n                .languages(Set.of(\"Latin\")).settings(Map.of(\"currency\", \"food\")).build();\n\n            repository.save(ada);\n\n            Optional&lt;User&gt; userFound = repository.findById(\"ada\");\n            System.out.println(userFound);\n\n            boolea userExist = repository.existsById(\"ada\");\n            System.out.println(\"userExist? = \" + userExist);\n\n            repository.deleteById(\"ada\");\n            userExist = repository.existsById(\"ada\");\n            System.out.println(\"userExist? = \" + userExist);\n        }\n    }\n\n    private AppRepository() {\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab/","title":"Redis - Lab 2","text":"<p>This lab will introduce the first integration between Java and Redis using Eclipse JNoSQL.</p> <p>Note</p> <p>The connection properties are already defined in the <code>src/main/java/resources/META-INF</code> folder in the <code>microprofile-config.properties</code>.</p> <p>The connection to Redis will be done using the database, port, and host defined there.</p>"},{"location":"key-value/java-lab/#1-the-first-integration","title":"1. The first integration","text":""},{"location":"key-value/java-lab/#steps","title":"Steps","text":"<ol> <li>Open the <code>03-key-value</code> project and navigate to the <code>src/main/java</code></li> <li>Create a class called <code>AppFirstIntegration</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain an instance of the <code>BucketManagerFactory</code> (specifically, <code>RedisBucketManagerFactory</code>) using Jakarta EE's dependency injection by adding the following inside the try-catch-resource block</p> <pre><code>BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n</code></pre> </li> <li> <p>Use the <code>BucketManagerFactory</code> to create and interact with data structures in Redis. In this case, a Redis list named \"names\" and a Redis set named \"fruits\" are created and retrieved</p> <ul> <li> <p>add the following code after the previous one:</p> <pre><code>List&lt;String&gt; names = factory.getList(\"names\", String.class);\nSet&lt;String&gt; fruits = factory.getSet(\"fruits\", String.class);\n</code></pre> </li> </ul> </li> <li> <p>Add data to the Redis list and set. In this example, names and fruits are added to the respective data structures</p> <ul> <li> <p>add the following code after the previous one:</p> <pre><code>names.addAll(List.of(\"Otavio\", \"Elias\", \"Ada\", \"Poliana\", \"Otavio\"));\nfruits.addAll(List.of(\"Banana\", \"Banana\", \"Apple\", \"Watermelon\", \"Banana\", \"Apple\"));\n</code></pre> </li> </ul> </li> <li> <p>Print the data stored in the \"names\" and \"fruits\" data structures:</p> <pre><code>System.out.println(\"Names: \");\nnames.forEach(System.out::println);\n\nSystem.out.println(\"Fruits: \");\nfruits.forEach(System.out::println);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>App</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppFirstIntegration() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"key-value/java-lab/#expected-results","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Names: \nOtavio\nElias\nAda\nPoliana\nOtavio\nFruits: \nApple\nWatermelon\nBanana\n</code></pre> </li> </ul>"},{"location":"key-value/java-lab/#solution","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.communication.keyvalue.BucketManagerFactory;\nimport org.eclipse.jnosql.databases.redis.communication.RedisBucketManagerFactory;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class AppFirstIntegration {\n\n    private AppFirstIntegration() {\n    }\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n\n            List&lt;String&gt; names = factory.getList(\"names\", String.class);\n            Set&lt;String&gt; fruits = factory.getSet(\"fruits\", String.class);\n\n            names.addAll(List.of(\"Otavio\", \"Elias\", \"Ada\", \"Poliana\", \"Otavio\"));\n            fruits.addAll(List.of(\"Banana\", \"Banana\", \"Apple\", \"Watermelon\", \"Banana\", \"Apple\"));\n\n            System.out.println(\"Names: \");\n            names.forEach(System.out::println);\n\n            System.out.println(\"Fruits: \");\n            fruits.forEach(System.out::println);\n        }\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab/#2-redis-and-a-queue","title":"2. Redis and a Queue","text":"<p>This lab will introduce the integration with Redis and a Queue.</p>"},{"location":"key-value/java-lab/#steps_1","title":"Steps","text":"<ol> <li>Create a class called <code>AppQueue</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain an instance of the <code>BucketManagerFactory</code> (specifically, <code>RedisBucketManagerFactory</code>) using Jakarta EE's dependency injection by adding the following inside the try-catch-resource block</p> <pre><code>BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n</code></pre> </li> <li> <p>Use the <code>BucketManagerFactory</code> to create and interact with a Redis queue named <code>orders</code> by using the method <code>getQueue</code></p> <ul> <li>the <code>Queue</code> class is from the <code>java.util</code> package</li> <li>its type is <code>String</code></li> <li> <p>the <code>getQueue()</code> key is name <code>\"orders\"</code> and the type is <code>String</code></p> <pre><code>Queue&lt;String&gt; orders = factory.getQueue(\"orders\", String.class);\n</code></pre> </li> </ul> </li> <li> <p>Clear the previous content using <code>orders.clear()</code> and then add the following items in the queue using the method <code>add(...)</code></p> <ul> <li>\"Phone\"</li> <li>\"Tablet\"</li> <li>\"Book\"</li> </ul> </li> <li> <p>Remove the element at the front of the queue using <code>orders.remove()</code></p> </li> <li>Peek at the element at the front of the queue using <code>orders.peek()</code></li> <li> <p>Print the contents of the Redis queue after performing the below operations</p> <pre><code>orders.forEach(System.out::println);\n</code></pre> </li> <li> <p>Define a private constructor for the <code>App</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppQueue() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"key-value/java-lab/#expected-results_1","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Table\nBook\n</code></pre> </li> </ul>"},{"location":"key-value/java-lab/#solution_1","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.communication.keyvalue.BucketManagerFactory;\nimport org.eclipse.jnosql.databases.redis.communication.RedisBucketManagerFactory;\n\nimport java.util.Queue;\n\npublic class AppQueue {\n\n    public static void main(String[] args) {\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n\n            Queue&lt;String&gt; orders = factory.getQueue(\"orders\", String.class);\n            orders.clear();\n            orders.add(\"Phone\");\n            orders.add(\"Tablet\");\n            orders.add(\"Book\");\n\n            orders.remove();\n            orders.peek();\n            orders.forEach(System.out::println);\n        }\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab/#3-redis-and-a-map","title":"3. Redis and a Map","text":""},{"location":"key-value/java-lab/#steps_2","title":"Steps","text":"<ol> <li>Create a class called <code>AppQueue</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain an instance of the <code>BucketManagerFactory</code> (specifically, <code>RedisBucketManagerFactory</code>) using Jakarta EE's dependency injection by adding the following inside the try-catch-resource block</p> <pre><code>BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n</code></pre> </li> <li> <p>Use the <code>BucketManagerFactory</code> to create and interact with a Redis map named <code>basket</code> by using the method <code>getBasket</code></p> <ul> <li>the <code>Map</code> must have the types as <code>Integer</code> and <code>String</code></li> <li>the <code>getMap()</code> the key is named <code>\"basket\"</code> and the types are Integer<code>and</code>String`</li> </ul> <pre><code> Map&lt;Integer, String&gt; basket = factory.getMap(\"basket\", Integer.class, String.class);\n</code></pre> </li> <li> <p>Clear the previous content using <code>orders.clear()</code> and then add the following items on the basket using the method <code>put(...)</code></p> key value 1 \"Banana\" 2 \"Watermelon\" 3 \"BaApplenana\" </li> <li> <p>Print the contents of the Redis queue after performing the below operations</p> <pre><code>basket.forEach((k, v) -&gt; System.out.println(k + \" - \" + v));\n</code></pre> </li> <li> <p>Define a private constructor for the <code>App</code> class to prevent instantiation since it contains only static methods:</p> <pre><code>private AppQueue() {\n}\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"key-value/java-lab/#expected-results_2","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>1 - Banana\n2 - Watermelon\n4 - Apple\n</code></pre> </li> </ul>"},{"location":"key-value/java-lab/#solution_2","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.communication.keyvalue.BucketManagerFactory;\nimport org.eclipse.jnosql.databases.redis.communication.RedisBucketManagerFactory;\n\nimport java.util.Map;\n\npublic class AppMap {\n\n    public static void main(String[] args) {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n\n            Map&lt;Integer, String&gt; basket = factory.getMap(\"basket\", Integer.class, String.class);\n            basket.clear();\n            basket.put(1, \"Banana\");\n            basket.put(2, \"Watermelon\");\n            basket.put(4, \"Apple\");\n\n            basket.forEach((k, v) -&gt; System.out.println(k + \" - \" + v));\n        }\n    }\n\n    private AppMap() {\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab/#4-redis-and-a-sortedmap","title":"4. Redis and a SortedMap","text":""},{"location":"key-value/java-lab/#steps_3","title":"Steps","text":"<ol> <li>Create a class called <code>AppSortedMap</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain an instance of the <code>BucketManagerFactory</code> (specifically, <code>RedisBucketManagerFactory</code>) using Jakarta EE's dependency injection by adding the following inside the try-catch-resource block</p> <pre><code>BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n</code></pre> </li> <li> <p>Use the <code>BucketManagerFactory</code> to create and interact with a Redis sorted map named <code>game</code> by using the method <code>getSortedSet</code></p> <ul> <li>the <code>SortedSet</code> is the field class</li> </ul> <pre><code>SortedSet game = factory.getSortedSet(\"game\");\n</code></pre> </li> <li> <p>Add the following itens in the game using the method <code>add(...)</code></p> key value \"Otavio\" 10 \"Elias\" 20 \"Ada 30 </li> <li> <p>Add one more item to the game, but using the <code>Ranking.of()</code> from <code>org.eclipse.jnosql.databases.redis.communication</code> package, adding:</p> key value \"Poliana\" 40 </li> <li> <p>Get the ranking, add it on a list</p> <pre><code>List&lt;Ranking&gt; ranking = game.getRanking();\n</code></pre> </li> <li> <p>Print out the ranking</p> <pre><code>System.out.println(\"Ranking: \" + ranking);\n</code></pre> </li> <li> <p>Print out the ranking in a reverse order</p> <pre><code>System.out.println(\"The reverse ranking: \" + game.getRevRanking());\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"key-value/java-lab/#expected-results_3","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Ranking: [DefaultRanking{point=10.0, member='Otavio'}, DefaultRanking{point=20.0, member='Elias'}, DefaultRanking{point=30.0, member='Ada'}, DefaultRanking{point=40.0, member='Poliana'}]\nThe reverse ranking: [DefaultRanking{point=40.0, member='Poliana'}, DefaultRanking{point=30.0, member='Ada'}, DefaultRanking{point=20.0, member='Elias'}, DefaultRanking{point=10.0, member='Otavio'}]\n</code></pre> </li> </ul>"},{"location":"key-value/java-lab/#solution_3","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.databases.redis.communication.Ranking;\nimport org.eclipse.jnosql.databases.redis.communication.RedisBucketManagerFactory;\nimport org.eclipse.jnosql.databases.redis.communication.SortedSet;\n\nimport java.util.List;\n\npublic class AppSortedMap {\n\n    public static void main(String[] args) {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            RedisBucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n\n            SortedSet game = factory.getSortedSet(\"game\");\n            game.add(\"Otavio\", 10);\n            game.add(\"Elias\", 20);\n            game.add(\"Ada\", 30);\n            game.add(Ranking.of(\"Poliana\", 40));\n\n            List&lt;Ranking&gt; ranking = game.getRanking();\n            System.out.println(\"Ranking: \" + ranking);\n            System.out.println(\"The reverse ranking: \" + game.getRevRanking());\n        }\n    }\n\n    private AppSortedMap() {\n    }\n}\n</code></pre>"},{"location":"key-value/java-lab/#5-redis-and-counter","title":"5. Redis and Counter","text":""},{"location":"key-value/java-lab/#steps_4","title":"Steps","text":"<ol> <li>Create a class called <code>AppSortedMap</code> in the <code>expert.os.labs.persistence</code> package</li> <li> <p>Add a main method</p> <pre><code>public static void main(String[] args) {\n}\n</code></pre> </li> <li> <p>Set up a try-with-resources block, inside the <code>main</code> method, to manage the Jakarta EE <code>SeContainer</code> that is responsible for dependency injection and managing resources</p> <pre><code>try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {     \n}\n</code></pre> </li> <li> <p>Obtain an instance of the <code>BucketManagerFactory</code> (specifically, <code>RedisBucketManagerFactory</code>) using Jakarta EE's dependency injection by adding the following inside the try-catch-resource block</p> <pre><code>BucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n</code></pre> </li> <li> <p>Use the <code>RedisBucketManagerFactory</code> to create and interact with Redis counters named \"home\" and \"products\" using the <code>counter()</code> method</p> <pre><code>Counter home = factory.getCounter(\"home\");\nCounter products = factory.getCounter(\"products\");\n</code></pre> </li> <li> <p>Increment the <code>home</code> and the <code>products</code> using the method <code>increment()</code></p> <pre><code>home.increment();\nproducts.increment();\n</code></pre> </li> <li> <p>Increment in 3 the <code>products</code></p> <pre><code>products.increment(3L);\n</code></pre> </li> <li> <p>Print out the <code>home</code> and <code>products</code> values</p> <pre><code>System.out.println(\"Home: \" + home.get());\nSystem.out.println(\"Products: \" + products.get());\n</code></pre> </li> <li> <p>Run the <code>main()</code> method</p> </li> </ol>"},{"location":"key-value/java-lab/#expected-results_4","title":"Expected results","text":"<ul> <li> <p>The following output</p> <pre><code>Home: 1.0\nProducts: 4.0\n</code></pre> </li> </ul>"},{"location":"key-value/java-lab/#solution_4","title":"Solution","text":"Click to see... <pre><code>import jakarta.enterprise.inject.se.SeContainer;\nimport jakarta.enterprise.inject.se.SeContainerInitializer;\nimport org.eclipse.jnosql.databases.redis.communication.Counter;\nimport org.eclipse.jnosql.databases.redis.communication.RedisBucketManagerFactory;\n\npublic class AppCounter {\n\n    public static void main(String[] args) {\n\n        try (SeContainer container = SeContainerInitializer.newInstance().initialize()) {\n            RedisBucketManagerFactory factory = container.select(RedisBucketManagerFactory.class).get();\n\n            Counter home = factory.getCounter(\"home\");\n            Counter products = factory.getCounter(\"products\");\n\n            home.increment();\n            products.increment();\n            products.increment(3L);\n\n            System.out.println(\"Home: \" + home.get());\n            System.out.println(\"Products: \" + products.get());\n        }\n    }\n\n    private AppCounter() {\n    }\n}\n</code></pre>"},{"location":"key-value/redis-commands/","title":"3.3 Redis commands","text":""},{"location":"key-value/redis-commands/#handy-redis-commands","title":"Handy Redis commands","text":"<p>The full list of commands can be found at https://redis.io/commands</p> Command Description <code>SET key value</code> Set a key with a string value. <code>GET key</code> Retrieve the value associated with a key. <code>INCR key</code> Increment the integer value of a key by 1. <code>DECR key</code> Decrement the integer value of a key by 1. <code>DEL key</code> Delete a key and its associated value(s). <code>KEYS pattern</code> Find all keys matching a specified pattern. <code>EXPIRE key seconds</code> Set an expiration time (in seconds) for a key. <code>TTL key</code> Get the remaining time to live of a key (in seconds). <code>HSET key field value</code> Set the field in a hash stored at a key to a value. <code>HGET key field</code> Retrieve the value of a field from a hash. <code>LPUSH key value [value]</code> Insert one or more values at the head of a list. <code>RPUSH key value [value]</code> Insert one or more values at the tail of a list. <code>LPOP key</code> Remove and return the first element from a list. <code>RPOP key</code> Remove and return the last element from a list."},{"location":"key-value/redis/","title":"Redis Overview","text":"<p>Redis, short for \"Remote Dictionary Server,\" is a lightning-fast, in-memory data store and cache that has emerged as a crucial component in modern application architecture. Renowned for its remarkable speed, flexibility, and simplicity, Redis provides a key-value data model that enables rapid data access and manipulation. It excels in various use cases, from caching frequently accessed data to supporting real-time analytics, message queuing, and more. As an open-source, in-memory database, Redis has become a go-to solution for developers and enterprises seeking to optimize data retrieval and processing in their applications, making it an integral part of the NoSQL landscape.</p>"},{"location":"key-value/redis/#main-features","title":"Main features","text":"<ol> <li> <p>In-Memory Data Store: Redis is an in-memory data store, which means it stores data in RAM, enabling lightning-fast read and write operations.</p> </li> <li> <p>Key-Value Data Model: Redis uses a simple key-value data model, where data is associated with unique keys, making it versatile and easy to use.</p> </li> <li> <p>Data Persistence: Redis supports various persistence options, allowing you to store data on disk for durability, in addition to in-memory storage.</p> </li> <li> <p>Data Structures: Redis provides a rich set of data structures, including strings, lists, sets, sorted sets, hashes, bitmaps, and more, making it suitable for various use cases.</p> </li> <li> <p>Pub/Sub Messaging: Redis offers publish/subscribe (pub/sub) messaging capabilities, allowing for real-time communication between components of an application.</p> </li> <li> <p>Replication: Redis supports master-slave replication, enabling data redundancy and high availability by replicating data to multiple nodes.</p> </li> <li> <p>Partitioning: Redis allows data partitioning, distributing data across multiple Redis instances, providing horizontal scalability.</p> </li> <li> <p>Lua Scripting: Redis supports Lua scripting, enabling users to execute custom scripts on the server-side for complex operations.</p> </li> <li> <p>Atomic Operations: Redis provides atomic operations for data manipulation, ensuring consistency in multi-step transactions.</p> </li> <li> <p>GeoSpatial Capabilities: Redis includes geospatial data support, allowing for the storage and querying of geolocation data, making it useful for location-based applications.</p> </li> </ol>"},{"location":"nosql/introduction/","title":"Introduction","text":"<p>NoSQL, or \"Not Only SQL,\" represents a new database management approach crucial in today's data-driven landscape. It's vital for several reasons:</p> <ol> <li> <p>Big Data: NoSQL databases handle vast data volumes, a necessity as data generation skyrockets.</p> </li> <li> <p>Scalability: They scale horizontally, which is crucial for high-traffic websites and enterprises.</p> </li> <li> <p>Flexibility: NoSQL adapts to changing data structures, ideal for agile development.</p> </li> <li> <p>Real-time Processing: It excels at real-time analytics, monitoring, and event-driven applications.</p> </li> <li> <p>Data Variety: NoSQL handles diverse data types, which is vital for modern applications.</p> </li> </ol> <p>Java's mature ecosystem and enterprise capabilities make it a perfect match for NoSQL:</p> <ol> <li> <p>Integration: Java SDKs and libraries simplify NoSQL database integration.</p> </li> <li> <p>Scalability: Java aligns well with NoSQL databases' scalability.</p> </li> <li> <p>Data Transformation: Java's libraries process data before storage, handy for complex structures.</p> </li> <li> <p>Middleware: Jakarta EE and Spring offer NoSQL support for enterprise applications.</p> </li> <li> <p>Security: Java ensures data security and transaction management.</p> </li> <li> <p>Enterprise Integration: Java's versatility connects with various data sources, including NoSQL, in enterprise applications.</p> </li> </ol>"}]}